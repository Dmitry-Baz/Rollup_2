var MyBundle = (function (require$$0, require$$0$1) {
  'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
  var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);

  var img = "data:image/jpeg;base64,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";

  // @ts-check
  /** @typedef { import('estree').BaseNode} BaseNode */

  /** @typedef {{
  	skip: () => void;
  	remove: () => void;
  	replace: (node: BaseNode) => void;
  }} WalkerContext */

  class WalkerBase {
  	constructor() {
  		/** @type {boolean} */
  		this.should_skip = false;

  		/** @type {boolean} */
  		this.should_remove = false;

  		/** @type {BaseNode | null} */
  		this.replacement = null;

  		/** @type {WalkerContext} */
  		this.context = {
  			skip: () => (this.should_skip = true),
  			remove: () => (this.should_remove = true),
  			replace: (node) => (this.replacement = node)
  		};
  	}

  	/**
  	 *
  	 * @param {any} parent
  	 * @param {string} prop
  	 * @param {number} index
  	 * @param {BaseNode} node
  	 */
  	replace(parent, prop, index, node) {
  		if (parent) {
  			if (index !== null) {
  				parent[prop][index] = node;
  			} else {
  				parent[prop] = node;
  			}
  		}
  	}

  	/**
  	 *
  	 * @param {any} parent
  	 * @param {string} prop
  	 * @param {number} index
  	 */
  	remove(parent, prop, index) {
  		if (parent) {
  			if (index !== null) {
  				parent[prop].splice(index, 1);
  			} else {
  				delete parent[prop];
  			}
  		}
  	}
  }

  // @ts-check

  /** @typedef { import('estree').BaseNode} BaseNode */
  /** @typedef { import('./walker.js').WalkerContext} WalkerContext */

  /** @typedef {(
   *    this: WalkerContext,
   *    node: BaseNode,
   *    parent: BaseNode,
   *    key: string,
   *    index: number
   * ) => void} SyncHandler */

  class SyncWalker extends WalkerBase {
  	/**
  	 *
  	 * @param {SyncHandler} enter
  	 * @param {SyncHandler} leave
  	 */
  	constructor(enter, leave) {
  		super();

  		/** @type {SyncHandler} */
  		this.enter = enter;

  		/** @type {SyncHandler} */
  		this.leave = leave;
  	}

  	/**
  	 *
  	 * @param {BaseNode} node
  	 * @param {BaseNode} parent
  	 * @param {string} [prop]
  	 * @param {number} [index]
  	 * @returns {BaseNode}
  	 */
  	visit(node, parent, prop, index) {
  		if (node) {
  			if (this.enter) {
  				const _should_skip = this.should_skip;
  				const _should_remove = this.should_remove;
  				const _replacement = this.replacement;
  				this.should_skip = false;
  				this.should_remove = false;
  				this.replacement = null;

  				this.enter.call(this.context, node, parent, prop, index);

  				if (this.replacement) {
  					node = this.replacement;
  					this.replace(parent, prop, index, node);
  				}

  				if (this.should_remove) {
  					this.remove(parent, prop, index);
  				}

  				const skipped = this.should_skip;
  				const removed = this.should_remove;

  				this.should_skip = _should_skip;
  				this.should_remove = _should_remove;
  				this.replacement = _replacement;

  				if (skipped) return node;
  				if (removed) return null;
  			}

  			for (const key in node) {
  				const value = node[key];

  				if (typeof value !== "object") {
  					continue;
  				} else if (Array.isArray(value)) {
  					for (let i = 0; i < value.length; i += 1) {
  						if (value[i] !== null && typeof value[i].type === 'string') {
  							if (!this.visit(value[i], node, key, i)) {
  								// removed
  								i--;
  							}
  						}
  					}
  				} else if (value !== null && typeof value.type === "string") {
  					this.visit(value, node, key, null);
  				}
  			}

  			if (this.leave) {
  				const _replacement = this.replacement;
  				const _should_remove = this.should_remove;
  				this.replacement = null;
  				this.should_remove = false;

  				this.leave.call(this.context, node, parent, prop, index);

  				if (this.replacement) {
  					node = this.replacement;
  					this.replace(parent, prop, index, node);
  				}

  				if (this.should_remove) {
  					this.remove(parent, prop, index);
  				}

  				const removed = this.should_remove;

  				this.replacement = _replacement;
  				this.should_remove = _should_remove;

  				if (removed) return null;
  			}
  		}

  		return node;
  	}
  }

  // @ts-check

  /** @typedef { import('estree').BaseNode} BaseNode */
  /** @typedef { import('./sync.js').SyncHandler} SyncHandler */
  /** @typedef { import('./async.js').AsyncHandler} AsyncHandler */

  /**
   *
   * @param {BaseNode} ast
   * @param {{
   *   enter?: SyncHandler
   *   leave?: SyncHandler
   * }} walker
   * @returns {BaseNode}
   */
  function walk(ast, { enter, leave }) {
  	const instance = new SyncWalker(enter, leave);
  	return instance.visit(ast, null);
  }

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var utils$1 = {};

  var constants;
  var hasRequiredConstants;

  function requireConstants () {
  	if (hasRequiredConstants) return constants;
  	hasRequiredConstants = 1;

  	const WIN_SLASH = '\\\\/';
  	const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

  	/**
  	 * Posix glob regex
  	 */

  	const DOT_LITERAL = '\\.';
  	const PLUS_LITERAL = '\\+';
  	const QMARK_LITERAL = '\\?';
  	const SLASH_LITERAL = '\\/';
  	const ONE_CHAR = '(?=.)';
  	const QMARK = '[^/]';
  	const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
  	const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  	const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  	const NO_DOT = `(?!${DOT_LITERAL})`;
  	const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  	const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  	const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  	const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  	const STAR = `${QMARK}*?`;
  	const SEP = '/';

  	const POSIX_CHARS = {
  	  DOT_LITERAL,
  	  PLUS_LITERAL,
  	  QMARK_LITERAL,
  	  SLASH_LITERAL,
  	  ONE_CHAR,
  	  QMARK,
  	  END_ANCHOR,
  	  DOTS_SLASH,
  	  NO_DOT,
  	  NO_DOTS,
  	  NO_DOT_SLASH,
  	  NO_DOTS_SLASH,
  	  QMARK_NO_DOT,
  	  STAR,
  	  START_ANCHOR,
  	  SEP
  	};

  	/**
  	 * Windows glob regex
  	 */

  	const WINDOWS_CHARS = {
  	  ...POSIX_CHARS,

  	  SLASH_LITERAL: `[${WIN_SLASH}]`,
  	  QMARK: WIN_NO_SLASH,
  	  STAR: `${WIN_NO_SLASH}*?`,
  	  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  	  NO_DOT: `(?!${DOT_LITERAL})`,
  	  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  	  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  	  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  	  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  	  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  	  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
  	  SEP: '\\'
  	};

  	/**
  	 * POSIX Bracket Regex
  	 */

  	const POSIX_REGEX_SOURCE = {
  	  alnum: 'a-zA-Z0-9',
  	  alpha: 'a-zA-Z',
  	  ascii: '\\x00-\\x7F',
  	  blank: ' \\t',
  	  cntrl: '\\x00-\\x1F\\x7F',
  	  digit: '0-9',
  	  graph: '\\x21-\\x7E',
  	  lower: 'a-z',
  	  print: '\\x20-\\x7E ',
  	  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  	  space: ' \\t\\r\\n\\v\\f',
  	  upper: 'A-Z',
  	  word: 'A-Za-z0-9_',
  	  xdigit: 'A-Fa-f0-9'
  	};

  	constants = {
  	  MAX_LENGTH: 1024 * 64,
  	  POSIX_REGEX_SOURCE,

  	  // regular expressions
  	  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  	  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  	  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  	  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  	  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  	  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  	  // Replace globs with equivalent patterns to reduce parsing time.
  	  REPLACEMENTS: {
  	    '***': '*',
  	    '**/**': '**',
  	    '**/**/**': '**'
  	  },

  	  // Digits
  	  CHAR_0: 48, /* 0 */
  	  CHAR_9: 57, /* 9 */

  	  // Alphabet chars.
  	  CHAR_UPPERCASE_A: 65, /* A */
  	  CHAR_LOWERCASE_A: 97, /* a */
  	  CHAR_UPPERCASE_Z: 90, /* Z */
  	  CHAR_LOWERCASE_Z: 122, /* z */

  	  CHAR_LEFT_PARENTHESES: 40, /* ( */
  	  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  	  CHAR_ASTERISK: 42, /* * */

  	  // Non-alphabetic chars.
  	  CHAR_AMPERSAND: 38, /* & */
  	  CHAR_AT: 64, /* @ */
  	  CHAR_BACKWARD_SLASH: 92, /* \ */
  	  CHAR_CARRIAGE_RETURN: 13, /* \r */
  	  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  	  CHAR_COLON: 58, /* : */
  	  CHAR_COMMA: 44, /* , */
  	  CHAR_DOT: 46, /* . */
  	  CHAR_DOUBLE_QUOTE: 34, /* " */
  	  CHAR_EQUAL: 61, /* = */
  	  CHAR_EXCLAMATION_MARK: 33, /* ! */
  	  CHAR_FORM_FEED: 12, /* \f */
  	  CHAR_FORWARD_SLASH: 47, /* / */
  	  CHAR_GRAVE_ACCENT: 96, /* ` */
  	  CHAR_HASH: 35, /* # */
  	  CHAR_HYPHEN_MINUS: 45, /* - */
  	  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  	  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  	  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  	  CHAR_LINE_FEED: 10, /* \n */
  	  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  	  CHAR_PERCENT: 37, /* % */
  	  CHAR_PLUS: 43, /* + */
  	  CHAR_QUESTION_MARK: 63, /* ? */
  	  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  	  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  	  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  	  CHAR_SEMICOLON: 59, /* ; */
  	  CHAR_SINGLE_QUOTE: 39, /* ' */
  	  CHAR_SPACE: 32, /*   */
  	  CHAR_TAB: 9, /* \t */
  	  CHAR_UNDERSCORE: 95, /* _ */
  	  CHAR_VERTICAL_LINE: 124, /* | */
  	  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  	  /**
  	   * Create EXTGLOB_CHARS
  	   */

  	  extglobChars(chars) {
  	    return {
  	      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
  	      '?': { type: 'qmark', open: '(?:', close: ')?' },
  	      '+': { type: 'plus', open: '(?:', close: ')+' },
  	      '*': { type: 'star', open: '(?:', close: ')*' },
  	      '@': { type: 'at', open: '(?:', close: ')' }
  	    };
  	  },

  	  /**
  	   * Create GLOB_CHARS
  	   */

  	  globChars(win32) {
  	    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  	  }
  	};
  	return constants;
  }

  /*global navigator*/

  var hasRequiredUtils$1;

  function requireUtils$1 () {
  	if (hasRequiredUtils$1) return utils$1;
  	hasRequiredUtils$1 = 1;
  	(function (exports) {

  		const {
  		  REGEX_BACKSLASH,
  		  REGEX_REMOVE_BACKSLASH,
  		  REGEX_SPECIAL_CHARS,
  		  REGEX_SPECIAL_CHARS_GLOBAL
  		} = /*@__PURE__*/ requireConstants();

  		exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
  		exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
  		exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
  		exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
  		exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

  		exports.isWindows = () => {
  		  if (typeof navigator !== 'undefined' && navigator.platform) {
  		    const platform = navigator.platform.toLowerCase();
  		    return platform === 'win32' || platform === 'windows';
  		  }

  		  if (typeof process !== 'undefined' && process.platform) {
  		    return process.platform === 'win32';
  		  }

  		  return false;
  		};

  		exports.removeBackslashes = str => {
  		  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
  		    return match === '\\' ? '' : match;
  		  });
  		};

  		exports.escapeLast = (input, char, lastIdx) => {
  		  const idx = input.lastIndexOf(char, lastIdx);
  		  if (idx === -1) return input;
  		  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  		  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  		};

  		exports.removePrefix = (input, state = {}) => {
  		  let output = input;
  		  if (output.startsWith('./')) {
  		    output = output.slice(2);
  		    state.prefix = './';
  		  }
  		  return output;
  		};

  		exports.wrapOutput = (input, state = {}, options = {}) => {
  		  const prepend = options.contains ? '' : '^';
  		  const append = options.contains ? '' : '$';

  		  let output = `${prepend}(?:${input})${append}`;
  		  if (state.negated === true) {
  		    output = `(?:^(?!${output}).*$)`;
  		  }
  		  return output;
  		};

  		exports.basename = (path, { windows } = {}) => {
  		  const segs = path.split(windows ? /[\\/]/ : '/');
  		  const last = segs[segs.length - 1];

  		  if (last === '') {
  		    return segs[segs.length - 2];
  		  }

  		  return last;
  		}; 
  	} (utils$1));
  	return utils$1;
  }

  var scan_1;
  var hasRequiredScan;

  function requireScan () {
  	if (hasRequiredScan) return scan_1;
  	hasRequiredScan = 1;

  	const utils = /*@__PURE__*/ requireUtils$1();
  	const {
  	  CHAR_ASTERISK,             /* * */
  	  CHAR_AT,                   /* @ */
  	  CHAR_BACKWARD_SLASH,       /* \ */
  	  CHAR_COMMA,                /* , */
  	  CHAR_DOT,                  /* . */
  	  CHAR_EXCLAMATION_MARK,     /* ! */
  	  CHAR_FORWARD_SLASH,        /* / */
  	  CHAR_LEFT_CURLY_BRACE,     /* { */
  	  CHAR_LEFT_PARENTHESES,     /* ( */
  	  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  	  CHAR_PLUS,                 /* + */
  	  CHAR_QUESTION_MARK,        /* ? */
  	  CHAR_RIGHT_CURLY_BRACE,    /* } */
  	  CHAR_RIGHT_PARENTHESES,    /* ) */
  	  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
  	} = /*@__PURE__*/ requireConstants();

  	const isPathSeparator = code => {
  	  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  	};

  	const depth = token => {
  	  if (token.isPrefix !== true) {
  	    token.depth = token.isGlobstar ? Infinity : 1;
  	  }
  	};

  	/**
  	 * Quickly scans a glob pattern and returns an object with a handful of
  	 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
  	 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
  	 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
  	 *
  	 * ```js
  	 * const pm = require('picomatch');
  	 * console.log(pm.scan('foo/bar/*.js'));
  	 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
  	 * ```
  	 * @param {String} `str`
  	 * @param {Object} `options`
  	 * @return {Object} Returns an object with tokens and regex source string.
  	 * @api public
  	 */

  	const scan = (input, options) => {
  	  const opts = options || {};

  	  const length = input.length - 1;
  	  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  	  const slashes = [];
  	  const tokens = [];
  	  const parts = [];

  	  let str = input;
  	  let index = -1;
  	  let start = 0;
  	  let lastIndex = 0;
  	  let isBrace = false;
  	  let isBracket = false;
  	  let isGlob = false;
  	  let isExtglob = false;
  	  let isGlobstar = false;
  	  let braceEscaped = false;
  	  let backslashes = false;
  	  let negated = false;
  	  let negatedExtglob = false;
  	  let finished = false;
  	  let braces = 0;
  	  let prev;
  	  let code;
  	  let token = { value: '', depth: 0, isGlob: false };

  	  const eos = () => index >= length;
  	  const peek = () => str.charCodeAt(index + 1);
  	  const advance = () => {
  	    prev = code;
  	    return str.charCodeAt(++index);
  	  };

  	  while (index < length) {
  	    code = advance();
  	    let next;

  	    if (code === CHAR_BACKWARD_SLASH) {
  	      backslashes = token.backslashes = true;
  	      code = advance();

  	      if (code === CHAR_LEFT_CURLY_BRACE) {
  	        braceEscaped = true;
  	      }
  	      continue;
  	    }

  	    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
  	      braces++;

  	      while (eos() !== true && (code = advance())) {
  	        if (code === CHAR_BACKWARD_SLASH) {
  	          backslashes = token.backslashes = true;
  	          advance();
  	          continue;
  	        }

  	        if (code === CHAR_LEFT_CURLY_BRACE) {
  	          braces++;
  	          continue;
  	        }

  	        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
  	          isBrace = token.isBrace = true;
  	          isGlob = token.isGlob = true;
  	          finished = true;

  	          if (scanToEnd === true) {
  	            continue;
  	          }

  	          break;
  	        }

  	        if (braceEscaped !== true && code === CHAR_COMMA) {
  	          isBrace = token.isBrace = true;
  	          isGlob = token.isGlob = true;
  	          finished = true;

  	          if (scanToEnd === true) {
  	            continue;
  	          }

  	          break;
  	        }

  	        if (code === CHAR_RIGHT_CURLY_BRACE) {
  	          braces--;

  	          if (braces === 0) {
  	            braceEscaped = false;
  	            isBrace = token.isBrace = true;
  	            finished = true;
  	            break;
  	          }
  	        }
  	      }

  	      if (scanToEnd === true) {
  	        continue;
  	      }

  	      break;
  	    }

  	    if (code === CHAR_FORWARD_SLASH) {
  	      slashes.push(index);
  	      tokens.push(token);
  	      token = { value: '', depth: 0, isGlob: false };

  	      if (finished === true) continue;
  	      if (prev === CHAR_DOT && index === (start + 1)) {
  	        start += 2;
  	        continue;
  	      }

  	      lastIndex = index + 1;
  	      continue;
  	    }

  	    if (opts.noext !== true) {
  	      const isExtglobChar = code === CHAR_PLUS
  	        || code === CHAR_AT
  	        || code === CHAR_ASTERISK
  	        || code === CHAR_QUESTION_MARK
  	        || code === CHAR_EXCLAMATION_MARK;

  	      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
  	        isGlob = token.isGlob = true;
  	        isExtglob = token.isExtglob = true;
  	        finished = true;
  	        if (code === CHAR_EXCLAMATION_MARK && index === start) {
  	          negatedExtglob = true;
  	        }

  	        if (scanToEnd === true) {
  	          while (eos() !== true && (code = advance())) {
  	            if (code === CHAR_BACKWARD_SLASH) {
  	              backslashes = token.backslashes = true;
  	              code = advance();
  	              continue;
  	            }

  	            if (code === CHAR_RIGHT_PARENTHESES) {
  	              isGlob = token.isGlob = true;
  	              finished = true;
  	              break;
  	            }
  	          }
  	          continue;
  	        }
  	        break;
  	      }
  	    }

  	    if (code === CHAR_ASTERISK) {
  	      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
  	      isGlob = token.isGlob = true;
  	      finished = true;

  	      if (scanToEnd === true) {
  	        continue;
  	      }
  	      break;
  	    }

  	    if (code === CHAR_QUESTION_MARK) {
  	      isGlob = token.isGlob = true;
  	      finished = true;

  	      if (scanToEnd === true) {
  	        continue;
  	      }
  	      break;
  	    }

  	    if (code === CHAR_LEFT_SQUARE_BRACKET) {
  	      while (eos() !== true && (next = advance())) {
  	        if (next === CHAR_BACKWARD_SLASH) {
  	          backslashes = token.backslashes = true;
  	          advance();
  	          continue;
  	        }

  	        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
  	          isBracket = token.isBracket = true;
  	          isGlob = token.isGlob = true;
  	          finished = true;
  	          break;
  	        }
  	      }

  	      if (scanToEnd === true) {
  	        continue;
  	      }

  	      break;
  	    }

  	    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
  	      negated = token.negated = true;
  	      start++;
  	      continue;
  	    }

  	    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
  	      isGlob = token.isGlob = true;

  	      if (scanToEnd === true) {
  	        while (eos() !== true && (code = advance())) {
  	          if (code === CHAR_LEFT_PARENTHESES) {
  	            backslashes = token.backslashes = true;
  	            code = advance();
  	            continue;
  	          }

  	          if (code === CHAR_RIGHT_PARENTHESES) {
  	            finished = true;
  	            break;
  	          }
  	        }
  	        continue;
  	      }
  	      break;
  	    }

  	    if (isGlob === true) {
  	      finished = true;

  	      if (scanToEnd === true) {
  	        continue;
  	      }

  	      break;
  	    }
  	  }

  	  if (opts.noext === true) {
  	    isExtglob = false;
  	    isGlob = false;
  	  }

  	  let base = str;
  	  let prefix = '';
  	  let glob = '';

  	  if (start > 0) {
  	    prefix = str.slice(0, start);
  	    str = str.slice(start);
  	    lastIndex -= start;
  	  }

  	  if (base && isGlob === true && lastIndex > 0) {
  	    base = str.slice(0, lastIndex);
  	    glob = str.slice(lastIndex);
  	  } else if (isGlob === true) {
  	    base = '';
  	    glob = str;
  	  } else {
  	    base = str;
  	  }

  	  if (base && base !== '' && base !== '/' && base !== str) {
  	    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
  	      base = base.slice(0, -1);
  	    }
  	  }

  	  if (opts.unescape === true) {
  	    if (glob) glob = utils.removeBackslashes(glob);

  	    if (base && backslashes === true) {
  	      base = utils.removeBackslashes(base);
  	    }
  	  }

  	  const state = {
  	    prefix,
  	    input,
  	    start,
  	    base,
  	    glob,
  	    isBrace,
  	    isBracket,
  	    isGlob,
  	    isExtglob,
  	    isGlobstar,
  	    negated,
  	    negatedExtglob
  	  };

  	  if (opts.tokens === true) {
  	    state.maxDepth = 0;
  	    if (!isPathSeparator(code)) {
  	      tokens.push(token);
  	    }
  	    state.tokens = tokens;
  	  }

  	  if (opts.parts === true || opts.tokens === true) {
  	    let prevIndex;

  	    for (let idx = 0; idx < slashes.length; idx++) {
  	      const n = prevIndex ? prevIndex + 1 : start;
  	      const i = slashes[idx];
  	      const value = input.slice(n, i);
  	      if (opts.tokens) {
  	        if (idx === 0 && start !== 0) {
  	          tokens[idx].isPrefix = true;
  	          tokens[idx].value = prefix;
  	        } else {
  	          tokens[idx].value = value;
  	        }
  	        depth(tokens[idx]);
  	        state.maxDepth += tokens[idx].depth;
  	      }
  	      if (idx !== 0 || value !== '') {
  	        parts.push(value);
  	      }
  	      prevIndex = i;
  	    }

  	    if (prevIndex && prevIndex + 1 < input.length) {
  	      const value = input.slice(prevIndex + 1);
  	      parts.push(value);

  	      if (opts.tokens) {
  	        tokens[tokens.length - 1].value = value;
  	        depth(tokens[tokens.length - 1]);
  	        state.maxDepth += tokens[tokens.length - 1].depth;
  	      }
  	    }

  	    state.slashes = slashes;
  	    state.parts = parts;
  	  }

  	  return state;
  	};

  	scan_1 = scan;
  	return scan_1;
  }

  var parse_1;
  var hasRequiredParse;

  function requireParse () {
  	if (hasRequiredParse) return parse_1;
  	hasRequiredParse = 1;

  	const constants = /*@__PURE__*/ requireConstants();
  	const utils = /*@__PURE__*/ requireUtils$1();

  	/**
  	 * Constants
  	 */

  	const {
  	  MAX_LENGTH,
  	  POSIX_REGEX_SOURCE,
  	  REGEX_NON_SPECIAL_CHARS,
  	  REGEX_SPECIAL_CHARS_BACKREF,
  	  REPLACEMENTS
  	} = constants;

  	/**
  	 * Helpers
  	 */

  	const expandRange = (args, options) => {
  	  if (typeof options.expandRange === 'function') {
  	    return options.expandRange(...args, options);
  	  }

  	  args.sort();
  	  const value = `[${args.join('-')}]`;

  	  try {
  	    /* eslint-disable-next-line no-new */
  	    new RegExp(value);
  	  } catch (ex) {
  	    return args.map(v => utils.escapeRegex(v)).join('..');
  	  }

  	  return value;
  	};

  	/**
  	 * Create the message for a syntax error
  	 */

  	const syntaxError = (type, char) => {
  	  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  	};

  	/**
  	 * Parse the given input string.
  	 * @param {String} input
  	 * @param {Object} options
  	 * @return {Object}
  	 */

  	const parse = (input, options) => {
  	  if (typeof input !== 'string') {
  	    throw new TypeError('Expected a string');
  	  }

  	  input = REPLACEMENTS[input] || input;

  	  const opts = { ...options };
  	  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  	  let len = input.length;
  	  if (len > max) {
  	    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  	  }

  	  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  	  const tokens = [bos];

  	  const capture = opts.capture ? '' : '?:';

  	  // create constants based on platform, for windows or posix
  	  const PLATFORM_CHARS = constants.globChars(opts.windows);
  	  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  	  const {
  	    DOT_LITERAL,
  	    PLUS_LITERAL,
  	    SLASH_LITERAL,
  	    ONE_CHAR,
  	    DOTS_SLASH,
  	    NO_DOT,
  	    NO_DOT_SLASH,
  	    NO_DOTS_SLASH,
  	    QMARK,
  	    QMARK_NO_DOT,
  	    STAR,
  	    START_ANCHOR
  	  } = PLATFORM_CHARS;

  	  const globstar = opts => {
  	    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  	  };

  	  const nodot = opts.dot ? '' : NO_DOT;
  	  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  	  let star = opts.bash === true ? globstar(opts) : STAR;

  	  if (opts.capture) {
  	    star = `(${star})`;
  	  }

  	  // minimatch options support
  	  if (typeof opts.noext === 'boolean') {
  	    opts.noextglob = opts.noext;
  	  }

  	  const state = {
  	    input,
  	    index: -1,
  	    start: 0,
  	    dot: opts.dot === true,
  	    consumed: '',
  	    output: '',
  	    prefix: '',
  	    backtrack: false,
  	    negated: false,
  	    brackets: 0,
  	    braces: 0,
  	    parens: 0,
  	    quotes: 0,
  	    globstar: false,
  	    tokens
  	  };

  	  input = utils.removePrefix(input, state);
  	  len = input.length;

  	  const extglobs = [];
  	  const braces = [];
  	  const stack = [];
  	  let prev = bos;
  	  let value;

  	  /**
  	   * Tokenizing helpers
  	   */

  	  const eos = () => state.index === len - 1;
  	  const peek = state.peek = (n = 1) => input[state.index + n];
  	  const advance = state.advance = () => input[++state.index] || '';
  	  const remaining = () => input.slice(state.index + 1);
  	  const consume = (value = '', num = 0) => {
  	    state.consumed += value;
  	    state.index += num;
  	  };

  	  const append = token => {
  	    state.output += token.output != null ? token.output : token.value;
  	    consume(token.value);
  	  };

  	  const negate = () => {
  	    let count = 1;

  	    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
  	      advance();
  	      state.start++;
  	      count++;
  	    }

  	    if (count % 2 === 0) {
  	      return false;
  	    }

  	    state.negated = true;
  	    state.start++;
  	    return true;
  	  };

  	  const increment = type => {
  	    state[type]++;
  	    stack.push(type);
  	  };

  	  const decrement = type => {
  	    state[type]--;
  	    stack.pop();
  	  };

  	  /**
  	   * Push tokens onto the tokens array. This helper speeds up
  	   * tokenizing by 1) helping us avoid backtracking as much as possible,
  	   * and 2) helping us avoid creating extra tokens when consecutive
  	   * characters are plain text. This improves performance and simplifies
  	   * lookbehinds.
  	   */

  	  const push = tok => {
  	    if (prev.type === 'globstar') {
  	      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
  	      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

  	      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
  	        state.output = state.output.slice(0, -prev.output.length);
  	        prev.type = 'star';
  	        prev.value = '*';
  	        prev.output = star;
  	        state.output += prev.output;
  	      }
  	    }

  	    if (extglobs.length && tok.type !== 'paren') {
  	      extglobs[extglobs.length - 1].inner += tok.value;
  	    }

  	    if (tok.value || tok.output) append(tok);
  	    if (prev && prev.type === 'text' && tok.type === 'text') {
  	      prev.output = (prev.output || prev.value) + tok.value;
  	      prev.value += tok.value;
  	      return;
  	    }

  	    tok.prev = prev;
  	    tokens.push(tok);
  	    prev = tok;
  	  };

  	  const extglobOpen = (type, value) => {
  	    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

  	    token.prev = prev;
  	    token.parens = state.parens;
  	    token.output = state.output;
  	    const output = (opts.capture ? '(' : '') + token.open;

  	    increment('parens');
  	    push({ type, value, output: state.output ? '' : ONE_CHAR });
  	    push({ type: 'paren', extglob: true, value: advance(), output });
  	    extglobs.push(token);
  	  };

  	  const extglobClose = token => {
  	    let output = token.close + (opts.capture ? ')' : '');
  	    let rest;

  	    if (token.type === 'negate') {
  	      let extglobStar = star;

  	      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
  	        extglobStar = globstar(opts);
  	      }

  	      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
  	        output = token.close = `)$))${extglobStar}`;
  	      }

  	      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
  	        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
  	        // In this case, we need to parse the string and use it in the output of the original pattern.
  	        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
  	        //
  	        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
  	        const expression = parse(rest, { ...options, fastpaths: false }).output;

  	        output = token.close = `)${expression})${extglobStar})`;
  	      }

  	      if (token.prev.type === 'bos') {
  	        state.negatedExtglob = true;
  	      }
  	    }

  	    push({ type: 'paren', extglob: true, value, output });
  	    decrement('parens');
  	  };

  	  /**
  	   * Fast paths
  	   */

  	  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
  	    let backslashes = false;

  	    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
  	      if (first === '\\') {
  	        backslashes = true;
  	        return m;
  	      }

  	      if (first === '?') {
  	        if (esc) {
  	          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
  	        }
  	        if (index === 0) {
  	          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
  	        }
  	        return QMARK.repeat(chars.length);
  	      }

  	      if (first === '.') {
  	        return DOT_LITERAL.repeat(chars.length);
  	      }

  	      if (first === '*') {
  	        if (esc) {
  	          return esc + first + (rest ? star : '');
  	        }
  	        return star;
  	      }
  	      return esc ? m : `\\${m}`;
  	    });

  	    if (backslashes === true) {
  	      if (opts.unescape === true) {
  	        output = output.replace(/\\/g, '');
  	      } else {
  	        output = output.replace(/\\+/g, m => {
  	          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
  	        });
  	      }
  	    }

  	    if (output === input && opts.contains === true) {
  	      state.output = input;
  	      return state;
  	    }

  	    state.output = utils.wrapOutput(output, state, options);
  	    return state;
  	  }

  	  /**
  	   * Tokenize input until we reach end-of-string
  	   */

  	  while (!eos()) {
  	    value = advance();

  	    if (value === '\u0000') {
  	      continue;
  	    }

  	    /**
  	     * Escaped characters
  	     */

  	    if (value === '\\') {
  	      const next = peek();

  	      if (next === '/' && opts.bash !== true) {
  	        continue;
  	      }

  	      if (next === '.' || next === ';') {
  	        continue;
  	      }

  	      if (!next) {
  	        value += '\\';
  	        push({ type: 'text', value });
  	        continue;
  	      }

  	      // collapse slashes to reduce potential for exploits
  	      const match = /^\\+/.exec(remaining());
  	      let slashes = 0;

  	      if (match && match[0].length > 2) {
  	        slashes = match[0].length;
  	        state.index += slashes;
  	        if (slashes % 2 !== 0) {
  	          value += '\\';
  	        }
  	      }

  	      if (opts.unescape === true) {
  	        value = advance();
  	      } else {
  	        value += advance();
  	      }

  	      if (state.brackets === 0) {
  	        push({ type: 'text', value });
  	        continue;
  	      }
  	    }

  	    /**
  	     * If we're inside a regex character class, continue
  	     * until we reach the closing bracket.
  	     */

  	    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
  	      if (opts.posix !== false && value === ':') {
  	        const inner = prev.value.slice(1);
  	        if (inner.includes('[')) {
  	          prev.posix = true;

  	          if (inner.includes(':')) {
  	            const idx = prev.value.lastIndexOf('[');
  	            const pre = prev.value.slice(0, idx);
  	            const rest = prev.value.slice(idx + 2);
  	            const posix = POSIX_REGEX_SOURCE[rest];
  	            if (posix) {
  	              prev.value = pre + posix;
  	              state.backtrack = true;
  	              advance();

  	              if (!bos.output && tokens.indexOf(prev) === 1) {
  	                bos.output = ONE_CHAR;
  	              }
  	              continue;
  	            }
  	          }
  	        }
  	      }

  	      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
  	        value = `\\${value}`;
  	      }

  	      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
  	        value = `\\${value}`;
  	      }

  	      if (opts.posix === true && value === '!' && prev.value === '[') {
  	        value = '^';
  	      }

  	      prev.value += value;
  	      append({ value });
  	      continue;
  	    }

  	    /**
  	     * If we're inside a quoted string, continue
  	     * until we reach the closing double quote.
  	     */

  	    if (state.quotes === 1 && value !== '"') {
  	      value = utils.escapeRegex(value);
  	      prev.value += value;
  	      append({ value });
  	      continue;
  	    }

  	    /**
  	     * Double quotes
  	     */

  	    if (value === '"') {
  	      state.quotes = state.quotes === 1 ? 0 : 1;
  	      if (opts.keepQuotes === true) {
  	        push({ type: 'text', value });
  	      }
  	      continue;
  	    }

  	    /**
  	     * Parentheses
  	     */

  	    if (value === '(') {
  	      increment('parens');
  	      push({ type: 'paren', value });
  	      continue;
  	    }

  	    if (value === ')') {
  	      if (state.parens === 0 && opts.strictBrackets === true) {
  	        throw new SyntaxError(syntaxError('opening', '('));
  	      }

  	      const extglob = extglobs[extglobs.length - 1];
  	      if (extglob && state.parens === extglob.parens + 1) {
  	        extglobClose(extglobs.pop());
  	        continue;
  	      }

  	      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
  	      decrement('parens');
  	      continue;
  	    }

  	    /**
  	     * Square brackets
  	     */

  	    if (value === '[') {
  	      if (opts.nobracket === true || !remaining().includes(']')) {
  	        if (opts.nobracket !== true && opts.strictBrackets === true) {
  	          throw new SyntaxError(syntaxError('closing', ']'));
  	        }

  	        value = `\\${value}`;
  	      } else {
  	        increment('brackets');
  	      }

  	      push({ type: 'bracket', value });
  	      continue;
  	    }

  	    if (value === ']') {
  	      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
  	        push({ type: 'text', value, output: `\\${value}` });
  	        continue;
  	      }

  	      if (state.brackets === 0) {
  	        if (opts.strictBrackets === true) {
  	          throw new SyntaxError(syntaxError('opening', '['));
  	        }

  	        push({ type: 'text', value, output: `\\${value}` });
  	        continue;
  	      }

  	      decrement('brackets');

  	      const prevValue = prev.value.slice(1);
  	      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
  	        value = `/${value}`;
  	      }

  	      prev.value += value;
  	      append({ value });

  	      // when literal brackets are explicitly disabled
  	      // assume we should match with a regex character class
  	      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
  	        continue;
  	      }

  	      const escaped = utils.escapeRegex(prev.value);
  	      state.output = state.output.slice(0, -prev.value.length);

  	      // when literal brackets are explicitly enabled
  	      // assume we should escape the brackets to match literal characters
  	      if (opts.literalBrackets === true) {
  	        state.output += escaped;
  	        prev.value = escaped;
  	        continue;
  	      }

  	      // when the user specifies nothing, try to match both
  	      prev.value = `(${capture}${escaped}|${prev.value})`;
  	      state.output += prev.value;
  	      continue;
  	    }

  	    /**
  	     * Braces
  	     */

  	    if (value === '{' && opts.nobrace !== true) {
  	      increment('braces');

  	      const open = {
  	        type: 'brace',
  	        value,
  	        output: '(',
  	        outputIndex: state.output.length,
  	        tokensIndex: state.tokens.length
  	      };

  	      braces.push(open);
  	      push(open);
  	      continue;
  	    }

  	    if (value === '}') {
  	      const brace = braces[braces.length - 1];

  	      if (opts.nobrace === true || !brace) {
  	        push({ type: 'text', value, output: value });
  	        continue;
  	      }

  	      let output = ')';

  	      if (brace.dots === true) {
  	        const arr = tokens.slice();
  	        const range = [];

  	        for (let i = arr.length - 1; i >= 0; i--) {
  	          tokens.pop();
  	          if (arr[i].type === 'brace') {
  	            break;
  	          }
  	          if (arr[i].type !== 'dots') {
  	            range.unshift(arr[i].value);
  	          }
  	        }

  	        output = expandRange(range, opts);
  	        state.backtrack = true;
  	      }

  	      if (brace.comma !== true && brace.dots !== true) {
  	        const out = state.output.slice(0, brace.outputIndex);
  	        const toks = state.tokens.slice(brace.tokensIndex);
  	        brace.value = brace.output = '\\{';
  	        value = output = '\\}';
  	        state.output = out;
  	        for (const t of toks) {
  	          state.output += (t.output || t.value);
  	        }
  	      }

  	      push({ type: 'brace', value, output });
  	      decrement('braces');
  	      braces.pop();
  	      continue;
  	    }

  	    /**
  	     * Pipes
  	     */

  	    if (value === '|') {
  	      if (extglobs.length > 0) {
  	        extglobs[extglobs.length - 1].conditions++;
  	      }
  	      push({ type: 'text', value });
  	      continue;
  	    }

  	    /**
  	     * Commas
  	     */

  	    if (value === ',') {
  	      let output = value;

  	      const brace = braces[braces.length - 1];
  	      if (brace && stack[stack.length - 1] === 'braces') {
  	        brace.comma = true;
  	        output = '|';
  	      }

  	      push({ type: 'comma', value, output });
  	      continue;
  	    }

  	    /**
  	     * Slashes
  	     */

  	    if (value === '/') {
  	      // if the beginning of the glob is "./", advance the start
  	      // to the current index, and don't add the "./" characters
  	      // to the state. This greatly simplifies lookbehinds when
  	      // checking for BOS characters like "!" and "." (not "./")
  	      if (prev.type === 'dot' && state.index === state.start + 1) {
  	        state.start = state.index + 1;
  	        state.consumed = '';
  	        state.output = '';
  	        tokens.pop();
  	        prev = bos; // reset "prev" to the first token
  	        continue;
  	      }

  	      push({ type: 'slash', value, output: SLASH_LITERAL });
  	      continue;
  	    }

  	    /**
  	     * Dots
  	     */

  	    if (value === '.') {
  	      if (state.braces > 0 && prev.type === 'dot') {
  	        if (prev.value === '.') prev.output = DOT_LITERAL;
  	        const brace = braces[braces.length - 1];
  	        prev.type = 'dots';
  	        prev.output += value;
  	        prev.value += value;
  	        brace.dots = true;
  	        continue;
  	      }

  	      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
  	        push({ type: 'text', value, output: DOT_LITERAL });
  	        continue;
  	      }

  	      push({ type: 'dot', value, output: DOT_LITERAL });
  	      continue;
  	    }

  	    /**
  	     * Question marks
  	     */

  	    if (value === '?') {
  	      const isGroup = prev && prev.value === '(';
  	      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
  	        extglobOpen('qmark', value);
  	        continue;
  	      }

  	      if (prev && prev.type === 'paren') {
  	        const next = peek();
  	        let output = value;

  	        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
  	          output = `\\${value}`;
  	        }

  	        push({ type: 'text', value, output });
  	        continue;
  	      }

  	      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
  	        push({ type: 'qmark', value, output: QMARK_NO_DOT });
  	        continue;
  	      }

  	      push({ type: 'qmark', value, output: QMARK });
  	      continue;
  	    }

  	    /**
  	     * Exclamation
  	     */

  	    if (value === '!') {
  	      if (opts.noextglob !== true && peek() === '(') {
  	        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
  	          extglobOpen('negate', value);
  	          continue;
  	        }
  	      }

  	      if (opts.nonegate !== true && state.index === 0) {
  	        negate();
  	        continue;
  	      }
  	    }

  	    /**
  	     * Plus
  	     */

  	    if (value === '+') {
  	      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
  	        extglobOpen('plus', value);
  	        continue;
  	      }

  	      if ((prev && prev.value === '(') || opts.regex === false) {
  	        push({ type: 'plus', value, output: PLUS_LITERAL });
  	        continue;
  	      }

  	      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
  	        push({ type: 'plus', value });
  	        continue;
  	      }

  	      push({ type: 'plus', value: PLUS_LITERAL });
  	      continue;
  	    }

  	    /**
  	     * Plain text
  	     */

  	    if (value === '@') {
  	      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
  	        push({ type: 'at', extglob: true, value, output: '' });
  	        continue;
  	      }

  	      push({ type: 'text', value });
  	      continue;
  	    }

  	    /**
  	     * Plain text
  	     */

  	    if (value !== '*') {
  	      if (value === '$' || value === '^') {
  	        value = `\\${value}`;
  	      }

  	      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
  	      if (match) {
  	        value += match[0];
  	        state.index += match[0].length;
  	      }

  	      push({ type: 'text', value });
  	      continue;
  	    }

  	    /**
  	     * Stars
  	     */

  	    if (prev && (prev.type === 'globstar' || prev.star === true)) {
  	      prev.type = 'star';
  	      prev.star = true;
  	      prev.value += value;
  	      prev.output = star;
  	      state.backtrack = true;
  	      state.globstar = true;
  	      consume(value);
  	      continue;
  	    }

  	    let rest = remaining();
  	    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
  	      extglobOpen('star', value);
  	      continue;
  	    }

  	    if (prev.type === 'star') {
  	      if (opts.noglobstar === true) {
  	        consume(value);
  	        continue;
  	      }

  	      const prior = prev.prev;
  	      const before = prior.prev;
  	      const isStart = prior.type === 'slash' || prior.type === 'bos';
  	      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

  	      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
  	        push({ type: 'star', value, output: '' });
  	        continue;
  	      }

  	      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
  	      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
  	      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
  	        push({ type: 'star', value, output: '' });
  	        continue;
  	      }

  	      // strip consecutive `/**/`
  	      while (rest.slice(0, 3) === '/**') {
  	        const after = input[state.index + 4];
  	        if (after && after !== '/') {
  	          break;
  	        }
  	        rest = rest.slice(3);
  	        consume('/**', 3);
  	      }

  	      if (prior.type === 'bos' && eos()) {
  	        prev.type = 'globstar';
  	        prev.value += value;
  	        prev.output = globstar(opts);
  	        state.output = prev.output;
  	        state.globstar = true;
  	        consume(value);
  	        continue;
  	      }

  	      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
  	        state.output = state.output.slice(0, -(prior.output + prev.output).length);
  	        prior.output = `(?:${prior.output}`;

  	        prev.type = 'globstar';
  	        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
  	        prev.value += value;
  	        state.globstar = true;
  	        state.output += prior.output + prev.output;
  	        consume(value);
  	        continue;
  	      }

  	      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
  	        const end = rest[1] !== void 0 ? '|$' : '';

  	        state.output = state.output.slice(0, -(prior.output + prev.output).length);
  	        prior.output = `(?:${prior.output}`;

  	        prev.type = 'globstar';
  	        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
  	        prev.value += value;

  	        state.output += prior.output + prev.output;
  	        state.globstar = true;

  	        consume(value + advance());

  	        push({ type: 'slash', value: '/', output: '' });
  	        continue;
  	      }

  	      if (prior.type === 'bos' && rest[0] === '/') {
  	        prev.type = 'globstar';
  	        prev.value += value;
  	        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
  	        state.output = prev.output;
  	        state.globstar = true;
  	        consume(value + advance());
  	        push({ type: 'slash', value: '/', output: '' });
  	        continue;
  	      }

  	      // remove single star from output
  	      state.output = state.output.slice(0, -prev.output.length);

  	      // reset previous token to globstar
  	      prev.type = 'globstar';
  	      prev.output = globstar(opts);
  	      prev.value += value;

  	      // reset output with globstar
  	      state.output += prev.output;
  	      state.globstar = true;
  	      consume(value);
  	      continue;
  	    }

  	    const token = { type: 'star', value, output: star };

  	    if (opts.bash === true) {
  	      token.output = '.*?';
  	      if (prev.type === 'bos' || prev.type === 'slash') {
  	        token.output = nodot + token.output;
  	      }
  	      push(token);
  	      continue;
  	    }

  	    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
  	      token.output = value;
  	      push(token);
  	      continue;
  	    }

  	    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
  	      if (prev.type === 'dot') {
  	        state.output += NO_DOT_SLASH;
  	        prev.output += NO_DOT_SLASH;

  	      } else if (opts.dot === true) {
  	        state.output += NO_DOTS_SLASH;
  	        prev.output += NO_DOTS_SLASH;

  	      } else {
  	        state.output += nodot;
  	        prev.output += nodot;
  	      }

  	      if (peek() !== '*') {
  	        state.output += ONE_CHAR;
  	        prev.output += ONE_CHAR;
  	      }
  	    }

  	    push(token);
  	  }

  	  while (state.brackets > 0) {
  	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
  	    state.output = utils.escapeLast(state.output, '[');
  	    decrement('brackets');
  	  }

  	  while (state.parens > 0) {
  	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
  	    state.output = utils.escapeLast(state.output, '(');
  	    decrement('parens');
  	  }

  	  while (state.braces > 0) {
  	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
  	    state.output = utils.escapeLast(state.output, '{');
  	    decrement('braces');
  	  }

  	  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
  	    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  	  }

  	  // rebuild the output if we had to backtrack at any point
  	  if (state.backtrack === true) {
  	    state.output = '';

  	    for (const token of state.tokens) {
  	      state.output += token.output != null ? token.output : token.value;

  	      if (token.suffix) {
  	        state.output += token.suffix;
  	      }
  	    }
  	  }

  	  return state;
  	};

  	/**
  	 * Fast paths for creating regular expressions for common glob patterns.
  	 * This can significantly speed up processing and has very little downside
  	 * impact when none of the fast paths match.
  	 */

  	parse.fastpaths = (input, options) => {
  	  const opts = { ...options };
  	  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  	  const len = input.length;
  	  if (len > max) {
  	    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  	  }

  	  input = REPLACEMENTS[input] || input;

  	  // create constants based on platform, for windows or posix
  	  const {
  	    DOT_LITERAL,
  	    SLASH_LITERAL,
  	    ONE_CHAR,
  	    DOTS_SLASH,
  	    NO_DOT,
  	    NO_DOTS,
  	    NO_DOTS_SLASH,
  	    STAR,
  	    START_ANCHOR
  	  } = constants.globChars(opts.windows);

  	  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  	  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  	  const capture = opts.capture ? '' : '?:';
  	  const state = { negated: false, prefix: '' };
  	  let star = opts.bash === true ? '.*?' : STAR;

  	  if (opts.capture) {
  	    star = `(${star})`;
  	  }

  	  const globstar = opts => {
  	    if (opts.noglobstar === true) return star;
  	    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  	  };

  	  const create = str => {
  	    switch (str) {
  	      case '*':
  	        return `${nodot}${ONE_CHAR}${star}`;

  	      case '.*':
  	        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

  	      case '*.*':
  	        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

  	      case '*/*':
  	        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

  	      case '**':
  	        return nodot + globstar(opts);

  	      case '**/*':
  	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

  	      case '**/*.*':
  	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

  	      case '**/.*':
  	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

  	      default: {
  	        const match = /^(.*?)\.(\w+)$/.exec(str);
  	        if (!match) return;

  	        const source = create(match[1]);
  	        if (!source) return;

  	        return source + DOT_LITERAL + match[2];
  	      }
  	    }
  	  };

  	  const output = utils.removePrefix(input, state);
  	  let source = create(output);

  	  if (source && opts.strictSlashes !== true) {
  	    source += `${SLASH_LITERAL}?`;
  	  }

  	  return source;
  	};

  	parse_1 = parse;
  	return parse_1;
  }

  var picomatch_1$1;
  var hasRequiredPicomatch$1;

  function requirePicomatch$1 () {
  	if (hasRequiredPicomatch$1) return picomatch_1$1;
  	hasRequiredPicomatch$1 = 1;

  	const scan = /*@__PURE__*/ requireScan();
  	const parse = /*@__PURE__*/ requireParse();
  	const utils = /*@__PURE__*/ requireUtils$1();
  	const constants = /*@__PURE__*/ requireConstants();
  	const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

  	/**
  	 * Creates a matcher function from one or more glob patterns. The
  	 * returned function takes a string to match as its first argument,
  	 * and returns true if the string is a match. The returned matcher
  	 * function also takes a boolean as the second argument that, when true,
  	 * returns an object with additional information.
  	 *
  	 * ```js
  	 * const picomatch = require('picomatch');
  	 * // picomatch(glob[, options]);
  	 *
  	 * const isMatch = picomatch('*.!(*a)');
  	 * console.log(isMatch('a.a')); //=> false
  	 * console.log(isMatch('a.b')); //=> true
  	 * ```
  	 * @name picomatch
  	 * @param {String|Array} `globs` One or more glob patterns.
  	 * @param {Object=} `options`
  	 * @return {Function=} Returns a matcher function.
  	 * @api public
  	 */

  	const picomatch = (glob, options, returnState = false) => {
  	  if (Array.isArray(glob)) {
  	    const fns = glob.map(input => picomatch(input, options, returnState));
  	    const arrayMatcher = str => {
  	      for (const isMatch of fns) {
  	        const state = isMatch(str);
  	        if (state) return state;
  	      }
  	      return false;
  	    };
  	    return arrayMatcher;
  	  }

  	  const isState = isObject(glob) && glob.tokens && glob.input;

  	  if (glob === '' || (typeof glob !== 'string' && !isState)) {
  	    throw new TypeError('Expected pattern to be a non-empty string');
  	  }

  	  const opts = options || {};
  	  const posix = opts.windows;
  	  const regex = isState
  	    ? picomatch.compileRe(glob, options)
  	    : picomatch.makeRe(glob, options, false, true);

  	  const state = regex.state;
  	  delete regex.state;

  	  let isIgnored = () => false;
  	  if (opts.ignore) {
  	    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
  	    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  	  }

  	  const matcher = (input, returnObject = false) => {
  	    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
  	    const result = { glob, state, regex, posix, input, output, match, isMatch };

  	    if (typeof opts.onResult === 'function') {
  	      opts.onResult(result);
  	    }

  	    if (isMatch === false) {
  	      result.isMatch = false;
  	      return returnObject ? result : false;
  	    }

  	    if (isIgnored(input)) {
  	      if (typeof opts.onIgnore === 'function') {
  	        opts.onIgnore(result);
  	      }
  	      result.isMatch = false;
  	      return returnObject ? result : false;
  	    }

  	    if (typeof opts.onMatch === 'function') {
  	      opts.onMatch(result);
  	    }
  	    return returnObject ? result : true;
  	  };

  	  if (returnState) {
  	    matcher.state = state;
  	  }

  	  return matcher;
  	};

  	/**
  	 * Test `input` with the given `regex`. This is used by the main
  	 * `picomatch()` function to test the input string.
  	 *
  	 * ```js
  	 * const picomatch = require('picomatch');
  	 * // picomatch.test(input, regex[, options]);
  	 *
  	 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
  	 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
  	 * ```
  	 * @param {String} `input` String to test.
  	 * @param {RegExp} `regex`
  	 * @return {Object} Returns an object with matching info.
  	 * @api public
  	 */

  	picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  	  if (typeof input !== 'string') {
  	    throw new TypeError('Expected input to be a string');
  	  }

  	  if (input === '') {
  	    return { isMatch: false, output: '' };
  	  }

  	  const opts = options || {};
  	  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  	  let match = input === glob;
  	  let output = (match && format) ? format(input) : input;

  	  if (match === false) {
  	    output = format ? format(input) : input;
  	    match = output === glob;
  	  }

  	  if (match === false || opts.capture === true) {
  	    if (opts.matchBase === true || opts.basename === true) {
  	      match = picomatch.matchBase(input, regex, options, posix);
  	    } else {
  	      match = regex.exec(output);
  	    }
  	  }

  	  return { isMatch: Boolean(match), match, output };
  	};

  	/**
  	 * Match the basename of a filepath.
  	 *
  	 * ```js
  	 * const picomatch = require('picomatch');
  	 * // picomatch.matchBase(input, glob[, options]);
  	 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
  	 * ```
  	 * @param {String} `input` String to test.
  	 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
  	 * @return {Boolean}
  	 * @api public
  	 */

  	picomatch.matchBase = (input, glob, options) => {
  	  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  	  return regex.test(utils.basename(input));
  	};

  	/**
  	 * Returns true if **any** of the given glob `patterns` match the specified `string`.
  	 *
  	 * ```js
  	 * const picomatch = require('picomatch');
  	 * // picomatch.isMatch(string, patterns[, options]);
  	 *
  	 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
  	 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
  	 * ```
  	 * @param {String|Array} str The string to test.
  	 * @param {String|Array} patterns One or more glob patterns to use for matching.
  	 * @param {Object} [options] See available [options](#options).
  	 * @return {Boolean} Returns true if any patterns match `str`
  	 * @api public
  	 */

  	picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

  	/**
  	 * Parse a glob pattern to create the source string for a regular
  	 * expression.
  	 *
  	 * ```js
  	 * const picomatch = require('picomatch');
  	 * const result = picomatch.parse(pattern[, options]);
  	 * ```
  	 * @param {String} `pattern`
  	 * @param {Object} `options`
  	 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
  	 * @api public
  	 */

  	picomatch.parse = (pattern, options) => {
  	  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  	  return parse(pattern, { ...options, fastpaths: false });
  	};

  	/**
  	 * Scan a glob pattern to separate the pattern into segments.
  	 *
  	 * ```js
  	 * const picomatch = require('picomatch');
  	 * // picomatch.scan(input[, options]);
  	 *
  	 * const result = picomatch.scan('!./foo/*.js');
  	 * console.log(result);
  	 * { prefix: '!./',
  	 *   input: '!./foo/*.js',
  	 *   start: 3,
  	 *   base: 'foo',
  	 *   glob: '*.js',
  	 *   isBrace: false,
  	 *   isBracket: false,
  	 *   isGlob: true,
  	 *   isExtglob: false,
  	 *   isGlobstar: false,
  	 *   negated: true }
  	 * ```
  	 * @param {String} `input` Glob pattern to scan.
  	 * @param {Object} `options`
  	 * @return {Object} Returns an object with
  	 * @api public
  	 */

  	picomatch.scan = (input, options) => scan(input, options);

  	/**
  	 * Compile a regular expression from the `state` object returned by the
  	 * [parse()](#parse) method.
  	 *
  	 * @param {Object} `state`
  	 * @param {Object} `options`
  	 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
  	 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
  	 * @return {RegExp}
  	 * @api public
  	 */

  	picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
  	  if (returnOutput === true) {
  	    return state.output;
  	  }

  	  const opts = options || {};
  	  const prepend = opts.contains ? '' : '^';
  	  const append = opts.contains ? '' : '$';

  	  let source = `${prepend}(?:${state.output})${append}`;
  	  if (state && state.negated === true) {
  	    source = `^(?!${source}).*$`;
  	  }

  	  const regex = picomatch.toRegex(source, options);
  	  if (returnState === true) {
  	    regex.state = state;
  	  }

  	  return regex;
  	};

  	/**
  	 * Create a regular expression from a parsed glob pattern.
  	 *
  	 * ```js
  	 * const picomatch = require('picomatch');
  	 * const state = picomatch.parse('*.js');
  	 * // picomatch.compileRe(state[, options]);
  	 *
  	 * console.log(picomatch.compileRe(state));
  	 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
  	 * ```
  	 * @param {String} `state` The object returned from the `.parse` method.
  	 * @param {Object} `options`
  	 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
  	 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
  	 * @return {RegExp} Returns a regex created from the given pattern.
  	 * @api public
  	 */

  	picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
  	  if (!input || typeof input !== 'string') {
  	    throw new TypeError('Expected a non-empty string');
  	  }

  	  let parsed = { negated: false, fastpaths: true };

  	  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
  	    parsed.output = parse.fastpaths(input, options);
  	  }

  	  if (!parsed.output) {
  	    parsed = parse(input, options);
  	  }

  	  return picomatch.compileRe(parsed, options, returnOutput, returnState);
  	};

  	/**
  	 * Create a regular expression from the given regex source string.
  	 *
  	 * ```js
  	 * const picomatch = require('picomatch');
  	 * // picomatch.toRegex(source[, options]);
  	 *
  	 * const { output } = picomatch.parse('*.js');
  	 * console.log(picomatch.toRegex(output));
  	 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
  	 * ```
  	 * @param {String} `source` Regular expression source string.
  	 * @param {Object} `options`
  	 * @return {RegExp}
  	 * @api public
  	 */

  	picomatch.toRegex = (source, options) => {
  	  try {
  	    const opts = options || {};
  	    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  	  } catch (err) {
  	    if (options && options.debug === true) throw err;
  	    return /$^/;
  	  }
  	};

  	/**
  	 * Picomatch constants.
  	 * @return {Object}
  	 */

  	picomatch.constants = constants;

  	/**
  	 * Expose "picomatch"
  	 */

  	picomatch_1$1 = picomatch;
  	return picomatch_1$1;
  }

  var picomatch_1;
  var hasRequiredPicomatch;

  function requirePicomatch () {
  	if (hasRequiredPicomatch) return picomatch_1;
  	hasRequiredPicomatch = 1;

  	const pico = /*@__PURE__*/ requirePicomatch$1();
  	const utils = /*@__PURE__*/ requireUtils$1();

  	function picomatch(glob, options, returnState = false) {
  	  // default to os.platform()
  	  if (options && (options.windows === null || options.windows === undefined)) {
  	    // don't mutate the original options object
  	    options = { ...options, windows: utils.isWindows() };
  	  }

  	  return pico(glob, options, returnState);
  	}

  	Object.assign(picomatch, pico);
  	picomatch_1 = picomatch;
  	return picomatch_1;
  }

  var picomatchExports = /*@__PURE__*/ requirePicomatch();
  var pm = /*@__PURE__*/getDefaultExportFromCjs(picomatchExports);

  const extractors = {
      ArrayPattern(names, param) {
          for (const element of param.elements) {
              if (element)
                  extractors[element.type](names, element);
          }
      },
      AssignmentPattern(names, param) {
          extractors[param.left.type](names, param.left);
      },
      Identifier(names, param) {
          names.push(param.name);
      },
      MemberExpression() { },
      ObjectPattern(names, param) {
          for (const prop of param.properties) {
              // @ts-ignore Typescript reports that this is not a valid type
              if (prop.type === 'RestElement') {
                  extractors.RestElement(names, prop);
              }
              else {
                  extractors[prop.value.type](names, prop.value);
              }
          }
      },
      RestElement(names, param) {
          extractors[param.argument.type](names, param.argument);
      }
  };
  const extractAssignedNames = function extractAssignedNames(param) {
      const names = [];
      extractors[param.type](names, param);
      return names;
  };

  const blockDeclarations = {
      const: true,
      let: true
  };
  class Scope {
      constructor(options = {}) {
          this.parent = options.parent;
          this.isBlockScope = !!options.block;
          this.declarations = Object.create(null);
          if (options.params) {
              options.params.forEach((param) => {
                  extractAssignedNames(param).forEach((name) => {
                      this.declarations[name] = true;
                  });
              });
          }
      }
      addDeclaration(node, isBlockDeclaration, isVar) {
          if (!isBlockDeclaration && this.isBlockScope) {
              // it's a `var` or function node, and this
              // is a block scope, so we need to go up
              this.parent.addDeclaration(node, isBlockDeclaration, isVar);
          }
          else if (node.id) {
              extractAssignedNames(node.id).forEach((name) => {
                  this.declarations[name] = true;
              });
          }
      }
      contains(name) {
          return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
      }
  }
  const attachScopes = function attachScopes(ast, propertyName = 'scope') {
      let scope = new Scope();
      walk(ast, {
          enter(n, parent) {
              const node = n;
              // function foo () {...}
              // class Foo {...}
              if (/(?:Function|Class)Declaration/.test(node.type)) {
                  scope.addDeclaration(node, false, false);
              }
              // var foo = 1
              if (node.type === 'VariableDeclaration') {
                  const { kind } = node;
                  const isBlockDeclaration = blockDeclarations[kind];
                  node.declarations.forEach((declaration) => {
                      scope.addDeclaration(declaration, isBlockDeclaration, true);
                  });
              }
              let newScope;
              // create new function scope
              if (/Function/.test(node.type)) {
                  const func = node;
                  newScope = new Scope({
                      parent: scope,
                      block: false,
                      params: func.params
                  });
                  // named function expressions - the name is considered
                  // part of the function's scope
                  if (func.type === 'FunctionExpression' && func.id) {
                      newScope.addDeclaration(func, false, false);
                  }
              }
              // create new for scope
              if (/For(?:In|Of)?Statement/.test(node.type)) {
                  newScope = new Scope({
                      parent: scope,
                      block: true
                  });
              }
              // create new block scope
              if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {
                  newScope = new Scope({
                      parent: scope,
                      block: true
                  });
              }
              // catch clause has its own block scope
              if (node.type === 'CatchClause') {
                  newScope = new Scope({
                      parent: scope,
                      params: node.param ? [node.param] : [],
                      block: true
                  });
              }
              if (newScope) {
                  Object.defineProperty(node, propertyName, {
                      value: newScope,
                      configurable: true
                  });
                  scope = newScope;
              }
          },
          leave(n) {
              const node = n;
              if (node[propertyName])
                  scope = scope.parent;
          }
      });
      return scope;
  };

  // Helper since Typescript can't detect readonly arrays with Array.isArray
  function isArray(arg) {
      return Array.isArray(arg);
  }
  function ensureArray(thing) {
      if (isArray(thing))
          return thing;
      if (thing == null)
          return [];
      return [thing];
  }

  const normalizePathRegExp = new RegExp(`\\${require$$0.win32.sep}`, 'g');
  const normalizePath = function normalizePath(filename) {
      return filename.replace(normalizePathRegExp, require$$0.posix.sep);
  };

  function getMatcherString(id, resolutionBase) {
      if (resolutionBase === false || require$$0.isAbsolute(id) || id.startsWith('**')) {
          return normalizePath(id);
      }
      // resolve('') is valid and will default to process.cwd()
      const basePath = normalizePath(require$$0.resolve(resolutionBase || ''))
          // escape all possible (posix + win) path characters that might interfere with regex
          .replace(/[-^$*+?.()|[\]{}]/g, '\\$&');
      // Note that we use posix.join because:
      // 1. the basePath has been normalized to use /
      // 2. the incoming glob (id) matcher, also uses /
      // otherwise Node will force backslash (\) on windows
      return require$$0.posix.join(basePath, normalizePath(id));
  }
  const createFilter = function createFilter(include, exclude, options) {
      const resolutionBase = options && options.resolve;
      const getMatcher = (id) => id instanceof RegExp
          ? id
          : {
              test: (what) => {
                  // this refactor is a tad overly verbose but makes for easy debugging
                  const pattern = getMatcherString(id, resolutionBase);
                  const fn = pm(pattern, { dot: true });
                  const result = fn(what);
                  return result;
              }
          };
      const includeMatchers = ensureArray(include).map(getMatcher);
      const excludeMatchers = ensureArray(exclude).map(getMatcher);
      if (!includeMatchers.length && !excludeMatchers.length)
          return (id) => typeof id === 'string' && !id.includes('\0');
      return function result(id) {
          if (typeof id !== 'string')
              return false;
          if (id.includes('\0'))
              return false;
          const pathId = normalizePath(id);
          for (let i = 0; i < excludeMatchers.length; ++i) {
              const matcher = excludeMatchers[i];
              if (matcher.test(pathId))
                  return false;
          }
          for (let i = 0; i < includeMatchers.length; ++i) {
              const matcher = includeMatchers[i];
              if (matcher.test(pathId))
                  return true;
          }
          return !includeMatchers.length;
      };
  };

  const reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';
  const builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';
  const forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));
  forbiddenIdentifiers.add('');
  const makeLegalIdentifier = function makeLegalIdentifier(str) {
      let identifier = str
          .replace(/-(\w)/g, (_, letter) => letter.toUpperCase())
          .replace(/[^$_a-zA-Z0-9]/g, '_');
      if (/\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {
          identifier = `_${identifier}`;
      }
      return identifier || '_';
  };

  var commondir;
  var hasRequiredCommondir;

  function requireCommondir () {
  	if (hasRequiredCommondir) return commondir;
  	hasRequiredCommondir = 1;
  	var path = require$$0__default["default"];

  	commondir = function (basedir, relfiles) {
  	    if (relfiles) {
  	        var files = relfiles.map(function (r) {
  	            return path.resolve(basedir, r);
  	        });
  	    }
  	    else {
  	        var files = basedir;
  	    }
  	    
  	    var res = files.slice(1).reduce(function (ps, file) {
  	        if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
  	            throw new Error('relative path without a basedir');
  	        }
  	        
  	        var xs = file.split(/\/+|\\+/);
  	        for (
  	            var i = 0;
  	            ps[i] === xs[i] && i < Math.min(ps.length, xs.length);
  	            i++
  	        );
  	        return ps.slice(0, i);
  	    }, files[0].split(/\/+|\\+/));
  	    
  	    // Windows correctly handles paths with forward-slashes
  	    return res.length > 1 ? res.join('/') : '/'
  	};
  	return commondir;
  }

  var commondirExports = requireCommondir();
  var getCommonDir = /*@__PURE__*/getDefaultExportFromCjs(commondirExports);

  var dist = {};

  var builder = {};

  var apiBuilder = {};

  var async = {};

  var walker = {};

  var utils = {};

  var hasRequiredUtils;

  function requireUtils () {
  	if (hasRequiredUtils) return utils;
  	hasRequiredUtils = 1;
  	Object.defineProperty(utils, "__esModule", { value: true });
  	utils.normalizePath = utils.convertSlashes = utils.cleanPath = void 0;
  	const path_1 = require$$0__default["default"];
  	function cleanPath(path) {
  	    let normalized = (0, path_1.normalize)(path);
  	    // we have to remove the last path separator
  	    // to account for / root path
  	    if (normalized.length > 1 && normalized[normalized.length - 1] === path_1.sep)
  	        normalized = normalized.substring(0, normalized.length - 1);
  	    return normalized;
  	}
  	utils.cleanPath = cleanPath;
  	const SLASHES_REGEX = /[\\/]/g;
  	function convertSlashes(path, separator) {
  	    return path.replace(SLASHES_REGEX, separator);
  	}
  	utils.convertSlashes = convertSlashes;
  	function normalizePath(path, options) {
  	    const { resolvePaths, normalizePath, pathSeparator } = options;
  	    const pathNeedsCleaning = (process.platform === "win32" && path.includes("/")) ||
  	        path.startsWith(".");
  	    if (resolvePaths)
  	        path = (0, path_1.resolve)(path);
  	    if (normalizePath || pathNeedsCleaning)
  	        path = cleanPath(path);
  	    if (path === ".")
  	        return "";
  	    const needsSeperator = path[path.length - 1] !== pathSeparator;
  	    return convertSlashes(needsSeperator ? path + pathSeparator : path, pathSeparator);
  	}
  	utils.normalizePath = normalizePath;
  	return utils;
  }

  var joinPath = {};

  var hasRequiredJoinPath;

  function requireJoinPath () {
  	if (hasRequiredJoinPath) return joinPath;
  	hasRequiredJoinPath = 1;
  	Object.defineProperty(joinPath, "__esModule", { value: true });
  	joinPath.build = joinPath.joinDirectoryPath = joinPath.joinPathWithBasePath = void 0;
  	const path_1 = require$$0__default["default"];
  	const utils_1 = requireUtils();
  	function joinPathWithBasePath(filename, directoryPath) {
  	    return directoryPath + filename;
  	}
  	joinPath.joinPathWithBasePath = joinPathWithBasePath;
  	function joinPathWithRelativePath(root, options) {
  	    return function (filename, directoryPath) {
  	        const sameRoot = directoryPath.startsWith(root);
  	        if (sameRoot)
  	            return directoryPath.replace(root, "") + filename;
  	        else
  	            return ((0, utils_1.convertSlashes)((0, path_1.relative)(root, directoryPath), options.pathSeparator) +
  	                options.pathSeparator +
  	                filename);
  	    };
  	}
  	function joinPath$1(filename) {
  	    return filename;
  	}
  	function joinDirectoryPath(filename, directoryPath, separator) {
  	    return directoryPath + filename + separator;
  	}
  	joinPath.joinDirectoryPath = joinDirectoryPath;
  	function build(root, options) {
  	    const { relativePaths, includeBasePath } = options;
  	    return relativePaths && root
  	        ? joinPathWithRelativePath(root, options)
  	        : includeBasePath
  	            ? joinPathWithBasePath
  	            : joinPath$1;
  	}
  	joinPath.build = build;
  	return joinPath;
  }

  var pushDirectory = {};

  var hasRequiredPushDirectory;

  function requirePushDirectory () {
  	if (hasRequiredPushDirectory) return pushDirectory;
  	hasRequiredPushDirectory = 1;
  	Object.defineProperty(pushDirectory, "__esModule", { value: true });
  	pushDirectory.build = void 0;
  	function pushDirectoryWithRelativePath(root) {
  	    return function (directoryPath, paths) {
  	        paths.push(directoryPath.substring(root.length) || ".");
  	    };
  	}
  	function pushDirectoryFilterWithRelativePath(root) {
  	    return function (directoryPath, paths, filters) {
  	        const relativePath = directoryPath.substring(root.length) || ".";
  	        if (filters.every((filter) => filter(relativePath, true))) {
  	            paths.push(relativePath);
  	        }
  	    };
  	}
  	const pushDirectory$1 = (directoryPath, paths) => {
  	    paths.push(directoryPath || ".");
  	};
  	const pushDirectoryFilter = (directoryPath, paths, filters) => {
  	    const path = directoryPath || ".";
  	    if (filters.every((filter) => filter(path, true))) {
  	        paths.push(path);
  	    }
  	};
  	const empty = () => { };
  	function build(root, options) {
  	    const { includeDirs, filters, relativePaths } = options;
  	    if (!includeDirs)
  	        return empty;
  	    if (relativePaths)
  	        return filters && filters.length
  	            ? pushDirectoryFilterWithRelativePath(root)
  	            : pushDirectoryWithRelativePath(root);
  	    return filters && filters.length ? pushDirectoryFilter : pushDirectory$1;
  	}
  	pushDirectory.build = build;
  	return pushDirectory;
  }

  var pushFile = {};

  var hasRequiredPushFile;

  function requirePushFile () {
  	if (hasRequiredPushFile) return pushFile;
  	hasRequiredPushFile = 1;
  	Object.defineProperty(pushFile, "__esModule", { value: true });
  	pushFile.build = void 0;
  	const pushFileFilterAndCount = (filename, _paths, counts, filters) => {
  	    if (filters.every((filter) => filter(filename, false)))
  	        counts.files++;
  	};
  	const pushFileFilter = (filename, paths, _counts, filters) => {
  	    if (filters.every((filter) => filter(filename, false)))
  	        paths.push(filename);
  	};
  	const pushFileCount = (_filename, _paths, counts, _filters) => {
  	    counts.files++;
  	};
  	const pushFile$1 = (filename, paths) => {
  	    paths.push(filename);
  	};
  	const empty = () => { };
  	function build(options) {
  	    const { excludeFiles, filters, onlyCounts } = options;
  	    if (excludeFiles)
  	        return empty;
  	    if (filters && filters.length) {
  	        return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
  	    }
  	    else if (onlyCounts) {
  	        return pushFileCount;
  	    }
  	    else {
  	        return pushFile$1;
  	    }
  	}
  	pushFile.build = build;
  	return pushFile;
  }

  var getArray = {};

  var hasRequiredGetArray;

  function requireGetArray () {
  	if (hasRequiredGetArray) return getArray;
  	hasRequiredGetArray = 1;
  	Object.defineProperty(getArray, "__esModule", { value: true });
  	getArray.build = void 0;
  	const getArray$1 = (paths) => {
  	    return paths;
  	};
  	const getArrayGroup = () => {
  	    return [""].slice(0, 0);
  	};
  	function build(options) {
  	    return options.group ? getArrayGroup : getArray$1;
  	}
  	getArray.build = build;
  	return getArray;
  }

  var groupFiles = {};

  var hasRequiredGroupFiles;

  function requireGroupFiles () {
  	if (hasRequiredGroupFiles) return groupFiles;
  	hasRequiredGroupFiles = 1;
  	Object.defineProperty(groupFiles, "__esModule", { value: true });
  	groupFiles.build = void 0;
  	const groupFiles$1 = (groups, directory, files) => {
  	    groups.push({ directory, files, dir: directory });
  	};
  	const empty = () => { };
  	function build(options) {
  	    return options.group ? groupFiles$1 : empty;
  	}
  	groupFiles.build = build;
  	return groupFiles;
  }

  var resolveSymlink = {};

  var hasRequiredResolveSymlink;

  function requireResolveSymlink () {
  	if (hasRequiredResolveSymlink) return resolveSymlink;
  	hasRequiredResolveSymlink = 1;
  	var __importDefault = (resolveSymlink && resolveSymlink.__importDefault) || function (mod) {
  	    return (mod && mod.__esModule) ? mod : { "default": mod };
  	};
  	Object.defineProperty(resolveSymlink, "__esModule", { value: true });
  	resolveSymlink.build = void 0;
  	const fs_1 = __importDefault(require$$0__default$1["default"]);
  	const path_1 = require$$0__default["default"];
  	const resolveSymlinksAsync = function (path, state, callback) {
  	    const { queue, options: { suppressErrors }, } = state;
  	    queue.enqueue();
  	    fs_1.default.realpath(path, (error, resolvedPath) => {
  	        if (error)
  	            return queue.dequeue(suppressErrors ? null : error, state);
  	        fs_1.default.stat(resolvedPath, (error, stat) => {
  	            if (error)
  	                return queue.dequeue(suppressErrors ? null : error, state);
  	            if (stat.isDirectory() && isRecursive(path, resolvedPath, state))
  	                return queue.dequeue(null, state);
  	            callback(stat, resolvedPath);
  	            queue.dequeue(null, state);
  	        });
  	    });
  	};
  	const resolveSymlinks = function (path, state, callback) {
  	    const { queue, options: { suppressErrors }, } = state;
  	    queue.enqueue();
  	    try {
  	        const resolvedPath = fs_1.default.realpathSync(path);
  	        const stat = fs_1.default.statSync(resolvedPath);
  	        if (stat.isDirectory() && isRecursive(path, resolvedPath, state))
  	            return;
  	        callback(stat, resolvedPath);
  	    }
  	    catch (e) {
  	        if (!suppressErrors)
  	            throw e;
  	    }
  	};
  	function build(options, isSynchronous) {
  	    if (!options.resolveSymlinks || options.excludeSymlinks)
  	        return null;
  	    return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
  	}
  	resolveSymlink.build = build;
  	function isRecursive(path, resolved, state) {
  	    if (state.options.useRealPaths)
  	        return isRecursiveUsingRealPaths(resolved, state);
  	    let parent = (0, path_1.dirname)(path);
  	    let depth = 1;
  	    while (parent !== state.root && depth < 2) {
  	        const resolvedPath = state.symlinks.get(parent);
  	        const isSameRoot = !!resolvedPath &&
  	            (resolvedPath === resolved ||
  	                resolvedPath.startsWith(resolved) ||
  	                resolved.startsWith(resolvedPath));
  	        if (isSameRoot)
  	            depth++;
  	        else
  	            parent = (0, path_1.dirname)(parent);
  	    }
  	    state.symlinks.set(path, resolved);
  	    return depth > 1;
  	}
  	function isRecursiveUsingRealPaths(resolved, state) {
  	    return state.visited.includes(resolved + state.options.pathSeparator);
  	}
  	return resolveSymlink;
  }

  var invokeCallback = {};

  var hasRequiredInvokeCallback;

  function requireInvokeCallback () {
  	if (hasRequiredInvokeCallback) return invokeCallback;
  	hasRequiredInvokeCallback = 1;
  	Object.defineProperty(invokeCallback, "__esModule", { value: true });
  	invokeCallback.build = void 0;
  	const onlyCountsSync = (state) => {
  	    return state.counts;
  	};
  	const groupsSync = (state) => {
  	    return state.groups;
  	};
  	const defaultSync = (state) => {
  	    return state.paths;
  	};
  	const limitFilesSync = (state) => {
  	    return state.paths.slice(0, state.options.maxFiles);
  	};
  	const onlyCountsAsync = (state, error, callback) => {
  	    report(error, callback, state.counts, state.options.suppressErrors);
  	    return null;
  	};
  	const defaultAsync = (state, error, callback) => {
  	    report(error, callback, state.paths, state.options.suppressErrors);
  	    return null;
  	};
  	const limitFilesAsync = (state, error, callback) => {
  	    report(error, callback, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
  	    return null;
  	};
  	const groupsAsync = (state, error, callback) => {
  	    report(error, callback, state.groups, state.options.suppressErrors);
  	    return null;
  	};
  	function report(error, callback, output, suppressErrors) {
  	    if (error && !suppressErrors)
  	        callback(error, output);
  	    else
  	        callback(null, output);
  	}
  	function build(options, isSynchronous) {
  	    const { onlyCounts, group, maxFiles } = options;
  	    if (onlyCounts)
  	        return isSynchronous
  	            ? onlyCountsSync
  	            : onlyCountsAsync;
  	    else if (group)
  	        return isSynchronous
  	            ? groupsSync
  	            : groupsAsync;
  	    else if (maxFiles)
  	        return isSynchronous
  	            ? limitFilesSync
  	            : limitFilesAsync;
  	    else
  	        return isSynchronous
  	            ? defaultSync
  	            : defaultAsync;
  	}
  	invokeCallback.build = build;
  	return invokeCallback;
  }

  var walkDirectory = {};

  var hasRequiredWalkDirectory;

  function requireWalkDirectory () {
  	if (hasRequiredWalkDirectory) return walkDirectory;
  	hasRequiredWalkDirectory = 1;
  	var __importDefault = (walkDirectory && walkDirectory.__importDefault) || function (mod) {
  	    return (mod && mod.__esModule) ? mod : { "default": mod };
  	};
  	Object.defineProperty(walkDirectory, "__esModule", { value: true });
  	walkDirectory.build = void 0;
  	const fs_1 = __importDefault(require$$0__default$1["default"]);
  	const readdirOpts = { withFileTypes: true };
  	const walkAsync = (state, crawlPath, directoryPath, currentDepth, callback) => {
  	    if (currentDepth < 0)
  	        return state.queue.dequeue(null, state);
  	    state.visited.push(crawlPath);
  	    state.counts.directories++;
  	    state.queue.enqueue();
  	    // Perf: Node >= 10 introduced withFileTypes that helps us
  	    // skip an extra fs.stat call.
  	    fs_1.default.readdir(crawlPath || ".", readdirOpts, (error, entries = []) => {
  	        callback(entries, directoryPath, currentDepth);
  	        state.queue.dequeue(state.options.suppressErrors ? null : error, state);
  	    });
  	};
  	const walkSync = (state, crawlPath, directoryPath, currentDepth, callback) => {
  	    if (currentDepth < 0)
  	        return;
  	    state.visited.push(crawlPath);
  	    state.counts.directories++;
  	    let entries = [];
  	    try {
  	        entries = fs_1.default.readdirSync(crawlPath || ".", readdirOpts);
  	    }
  	    catch (e) {
  	        if (!state.options.suppressErrors)
  	            throw e;
  	    }
  	    callback(entries, directoryPath, currentDepth);
  	};
  	function build(isSynchronous) {
  	    return isSynchronous ? walkSync : walkAsync;
  	}
  	walkDirectory.build = build;
  	return walkDirectory;
  }

  var queue = {};

  var hasRequiredQueue;

  function requireQueue () {
  	if (hasRequiredQueue) return queue;
  	hasRequiredQueue = 1;
  	Object.defineProperty(queue, "__esModule", { value: true });
  	queue.Queue = void 0;
  	/**
  	 * This is a custom stateless queue to track concurrent async fs calls.
  	 * It increments a counter whenever a call is queued and decrements it
  	 * as soon as it completes. When the counter hits 0, it calls onQueueEmpty.
  	 */
  	class Queue {
  	    onQueueEmpty;
  	    count = 0;
  	    constructor(onQueueEmpty) {
  	        this.onQueueEmpty = onQueueEmpty;
  	    }
  	    enqueue() {
  	        this.count++;
  	    }
  	    dequeue(error, output) {
  	        if (--this.count <= 0 || error)
  	            this.onQueueEmpty(error, output);
  	    }
  	}
  	queue.Queue = Queue;
  	return queue;
  }

  var counter = {};

  var hasRequiredCounter;

  function requireCounter () {
  	if (hasRequiredCounter) return counter;
  	hasRequiredCounter = 1;
  	Object.defineProperty(counter, "__esModule", { value: true });
  	counter.Counter = void 0;
  	class Counter {
  	    _files = 0;
  	    _directories = 0;
  	    set files(num) {
  	        this._files = num;
  	    }
  	    get files() {
  	        return this._files;
  	    }
  	    set directories(num) {
  	        this._directories = num;
  	    }
  	    get directories() {
  	        return this._directories;
  	    }
  	    /**
  	     * @deprecated use `directories` instead
  	     */
  	    /* c8 ignore next 3 */
  	    get dirs() {
  	        return this._directories;
  	    }
  	}
  	counter.Counter = Counter;
  	return counter;
  }

  var hasRequiredWalker;

  function requireWalker () {
  	if (hasRequiredWalker) return walker;
  	hasRequiredWalker = 1;
  	var __createBinding = (walker && walker.__createBinding) || (Object.create ? (function(o, m, k, k2) {
  	    if (k2 === undefined) k2 = k;
  	    var desc = Object.getOwnPropertyDescriptor(m, k);
  	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
  	      desc = { enumerable: true, get: function() { return m[k]; } };
  	    }
  	    Object.defineProperty(o, k2, desc);
  	}) : (function(o, m, k, k2) {
  	    if (k2 === undefined) k2 = k;
  	    o[k2] = m[k];
  	}));
  	var __setModuleDefault = (walker && walker.__setModuleDefault) || (Object.create ? (function(o, v) {
  	    Object.defineProperty(o, "default", { enumerable: true, value: v });
  	}) : function(o, v) {
  	    o["default"] = v;
  	});
  	var __importStar = (walker && walker.__importStar) || function (mod) {
  	    if (mod && mod.__esModule) return mod;
  	    var result = {};
  	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  	    __setModuleDefault(result, mod);
  	    return result;
  	};
  	Object.defineProperty(walker, "__esModule", { value: true });
  	walker.Walker = void 0;
  	const path_1 = require$$0__default["default"];
  	const utils_1 = requireUtils();
  	const joinPath = __importStar(requireJoinPath());
  	const pushDirectory = __importStar(requirePushDirectory());
  	const pushFile = __importStar(requirePushFile());
  	const getArray = __importStar(requireGetArray());
  	const groupFiles = __importStar(requireGroupFiles());
  	const resolveSymlink = __importStar(requireResolveSymlink());
  	const invokeCallback = __importStar(requireInvokeCallback());
  	const walkDirectory = __importStar(requireWalkDirectory());
  	const queue_1 = requireQueue();
  	const counter_1 = requireCounter();
  	class Walker {
  	    root;
  	    isSynchronous;
  	    state;
  	    joinPath;
  	    pushDirectory;
  	    pushFile;
  	    getArray;
  	    groupFiles;
  	    resolveSymlink;
  	    walkDirectory;
  	    callbackInvoker;
  	    constructor(root, options, callback) {
  	        this.isSynchronous = !callback;
  	        this.callbackInvoker = invokeCallback.build(options, this.isSynchronous);
  	        this.root = (0, utils_1.normalizePath)(root, options);
  	        this.state = {
  	            root: this.root.slice(0, -1),
  	            // Perf: we explicitly tell the compiler to optimize for String arrays
  	            paths: [""].slice(0, 0),
  	            groups: [],
  	            counts: new counter_1.Counter(),
  	            options,
  	            queue: new queue_1.Queue((error, state) => this.callbackInvoker(state, error, callback)),
  	            symlinks: new Map(),
  	            visited: [""].slice(0, 0),
  	        };
  	        /*
  	         * Perf: We conditionally change functions according to options. This gives a slight
  	         * performance boost. Since these functions are so small, they are automatically inlined
  	         * by the javascript engine so there's no function call overhead (in most cases).
  	         */
  	        this.joinPath = joinPath.build(this.root, options);
  	        this.pushDirectory = pushDirectory.build(this.root, options);
  	        this.pushFile = pushFile.build(options);
  	        this.getArray = getArray.build(options);
  	        this.groupFiles = groupFiles.build(options);
  	        this.resolveSymlink = resolveSymlink.build(options, this.isSynchronous);
  	        this.walkDirectory = walkDirectory.build(this.isSynchronous);
  	    }
  	    start() {
  	        this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);
  	        return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
  	    }
  	    walk = (entries, directoryPath, depth) => {
  	        const { paths, options: { filters, resolveSymlinks, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator, }, } = this.state;
  	        if ((signal && signal.aborted) || (maxFiles && paths.length > maxFiles))
  	            return;
  	        this.pushDirectory(directoryPath, paths, filters);
  	        const files = this.getArray(this.state.paths);
  	        for (let i = 0; i < entries.length; ++i) {
  	            const entry = entries[i];
  	            if (entry.isFile() ||
  	                (entry.isSymbolicLink() && !resolveSymlinks && !excludeSymlinks)) {
  	                const filename = this.joinPath(entry.name, directoryPath);
  	                this.pushFile(filename, files, this.state.counts, filters);
  	            }
  	            else if (entry.isDirectory()) {
  	                let path = joinPath.joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
  	                if (exclude && exclude(entry.name, path))
  	                    continue;
  	                this.walkDirectory(this.state, path, path, depth - 1, this.walk);
  	            }
  	            else if (entry.isSymbolicLink() && this.resolveSymlink) {
  	                let path = joinPath.joinPathWithBasePath(entry.name, directoryPath);
  	                this.resolveSymlink(path, this.state, (stat, resolvedPath) => {
  	                    if (stat.isDirectory()) {
  	                        resolvedPath = (0, utils_1.normalizePath)(resolvedPath, this.state.options);
  	                        if (exclude && exclude(entry.name, resolvedPath))
  	                            return;
  	                        this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path + pathSeparator, depth - 1, this.walk);
  	                    }
  	                    else {
  	                        resolvedPath = useRealPaths ? resolvedPath : path;
  	                        const filename = (0, path_1.basename)(resolvedPath);
  	                        const directoryPath = (0, utils_1.normalizePath)((0, path_1.dirname)(resolvedPath), this.state.options);
  	                        resolvedPath = this.joinPath(filename, directoryPath);
  	                        this.pushFile(resolvedPath, files, this.state.counts, filters);
  	                    }
  	                });
  	            }
  	        }
  	        this.groupFiles(this.state.groups, directoryPath, files);
  	    };
  	}
  	walker.Walker = Walker;
  	return walker;
  }

  var hasRequiredAsync;

  function requireAsync () {
  	if (hasRequiredAsync) return async;
  	hasRequiredAsync = 1;
  	Object.defineProperty(async, "__esModule", { value: true });
  	async.callback = async.promise = void 0;
  	const walker_1 = requireWalker();
  	function promise(root, options) {
  	    return new Promise((resolve, reject) => {
  	        callback(root, options, (err, output) => {
  	            if (err)
  	                return reject(err);
  	            resolve(output);
  	        });
  	    });
  	}
  	async.promise = promise;
  	function callback(root, options, callback) {
  	    let walker = new walker_1.Walker(root, options, callback);
  	    walker.start();
  	}
  	async.callback = callback;
  	return async;
  }

  var sync = {};

  var hasRequiredSync;

  function requireSync () {
  	if (hasRequiredSync) return sync;
  	hasRequiredSync = 1;
  	Object.defineProperty(sync, "__esModule", { value: true });
  	sync.sync = void 0;
  	const walker_1 = requireWalker();
  	function sync$1(root, options) {
  	    const walker = new walker_1.Walker(root, options);
  	    return walker.start();
  	}
  	sync.sync = sync$1;
  	return sync;
  }

  var hasRequiredApiBuilder;

  function requireApiBuilder () {
  	if (hasRequiredApiBuilder) return apiBuilder;
  	hasRequiredApiBuilder = 1;
  	Object.defineProperty(apiBuilder, "__esModule", { value: true });
  	apiBuilder.APIBuilder = void 0;
  	const async_1 = requireAsync();
  	const sync_1 = requireSync();
  	class APIBuilder {
  	    root;
  	    options;
  	    constructor(root, options) {
  	        this.root = root;
  	        this.options = options;
  	    }
  	    withPromise() {
  	        return (0, async_1.promise)(this.root, this.options);
  	    }
  	    withCallback(cb) {
  	        (0, async_1.callback)(this.root, this.options, cb);
  	    }
  	    sync() {
  	        return (0, sync_1.sync)(this.root, this.options);
  	    }
  	}
  	apiBuilder.APIBuilder = APIBuilder;
  	return apiBuilder;
  }

  var hasRequiredBuilder;

  function requireBuilder () {
  	if (hasRequiredBuilder) return builder;
  	hasRequiredBuilder = 1;
  	Object.defineProperty(builder, "__esModule", { value: true });
  	builder.Builder = void 0;
  	const path_1 = require$$0__default["default"];
  	const api_builder_1 = requireApiBuilder();
  	var pm = null;
  	/* c8 ignore next 6 */
  	try {
  	    require.resolve("picomatch");
  	    pm = /*@__PURE__*/ requirePicomatch();
  	}
  	catch (_e) {
  	    // do nothing
  	}
  	class Builder {
  	    globCache = {};
  	    options = {
  	        maxDepth: Infinity,
  	        suppressErrors: true,
  	        pathSeparator: path_1.sep,
  	        filters: [],
  	    };
  	    globFunction;
  	    constructor(options) {
  	        this.options = { ...this.options, ...options };
  	        this.globFunction = this.options.globFunction;
  	    }
  	    group() {
  	        this.options.group = true;
  	        return this;
  	    }
  	    withPathSeparator(separator) {
  	        this.options.pathSeparator = separator;
  	        return this;
  	    }
  	    withBasePath() {
  	        this.options.includeBasePath = true;
  	        return this;
  	    }
  	    withRelativePaths() {
  	        this.options.relativePaths = true;
  	        return this;
  	    }
  	    withDirs() {
  	        this.options.includeDirs = true;
  	        return this;
  	    }
  	    withMaxDepth(depth) {
  	        this.options.maxDepth = depth;
  	        return this;
  	    }
  	    withMaxFiles(limit) {
  	        this.options.maxFiles = limit;
  	        return this;
  	    }
  	    withFullPaths() {
  	        this.options.resolvePaths = true;
  	        this.options.includeBasePath = true;
  	        return this;
  	    }
  	    withErrors() {
  	        this.options.suppressErrors = false;
  	        return this;
  	    }
  	    withSymlinks({ resolvePaths = true } = {}) {
  	        this.options.resolveSymlinks = true;
  	        this.options.useRealPaths = resolvePaths;
  	        return this.withFullPaths();
  	    }
  	    withAbortSignal(signal) {
  	        this.options.signal = signal;
  	        return this;
  	    }
  	    normalize() {
  	        this.options.normalizePath = true;
  	        return this;
  	    }
  	    filter(predicate) {
  	        this.options.filters.push(predicate);
  	        return this;
  	    }
  	    onlyDirs() {
  	        this.options.excludeFiles = true;
  	        this.options.includeDirs = true;
  	        return this;
  	    }
  	    exclude(predicate) {
  	        this.options.exclude = predicate;
  	        return this;
  	    }
  	    onlyCounts() {
  	        this.options.onlyCounts = true;
  	        return this;
  	    }
  	    crawl(root) {
  	        return new api_builder_1.APIBuilder(root || ".", this.options);
  	    }
  	    withGlobFunction(fn) {
  	        // cast this since we don't have the new type params yet
  	        this.globFunction = fn;
  	        return this;
  	    }
  	    /**
  	     * @deprecated Pass options using the constructor instead:
  	     * ```ts
  	     * new fdir(options).crawl("/path/to/root");
  	     * ```
  	     * This method will be removed in v7.0
  	     */
  	    /* c8 ignore next 4 */
  	    crawlWithOptions(root, options) {
  	        this.options = { ...this.options, ...options };
  	        return new api_builder_1.APIBuilder(root || ".", this.options);
  	    }
  	    glob(...patterns) {
  	        if (this.globFunction) {
  	            return this.globWithOptions(patterns);
  	        }
  	        return this.globWithOptions(patterns, ...[{ dot: true }]);
  	    }
  	    globWithOptions(patterns, ...options) {
  	        const globFn = (this.globFunction || pm);
  	        /* c8 ignore next 5 */
  	        if (!globFn) {
  	            throw new Error('Please specify a glob function to use glob matching.');
  	        }
  	        var isMatch = this.globCache[patterns.join("\0")];
  	        if (!isMatch) {
  	            isMatch = globFn(patterns, ...options);
  	            this.globCache[patterns.join("\0")] = isMatch;
  	        }
  	        this.options.filters.push((path) => isMatch(path));
  	        return this;
  	    }
  	}
  	builder.Builder = Builder;
  	return builder;
  }

  var types = {};

  var hasRequiredTypes;

  function requireTypes () {
  	if (hasRequiredTypes) return types;
  	hasRequiredTypes = 1;
  	Object.defineProperty(types, "__esModule", { value: true });
  	return types;
  }

  var hasRequiredDist;

  function requireDist () {
  	if (hasRequiredDist) return dist;
  	hasRequiredDist = 1;
  	(function (exports) {
  		var __createBinding = (dist && dist.__createBinding) || (Object.create ? (function(o, m, k, k2) {
  		    if (k2 === undefined) k2 = k;
  		    var desc = Object.getOwnPropertyDescriptor(m, k);
  		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
  		      desc = { enumerable: true, get: function() { return m[k]; } };
  		    }
  		    Object.defineProperty(o, k2, desc);
  		}) : (function(o, m, k, k2) {
  		    if (k2 === undefined) k2 = k;
  		    o[k2] = m[k];
  		}));
  		var __exportStar = (dist && dist.__exportStar) || function(m, exports) {
  		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  		};
  		Object.defineProperty(exports, "__esModule", { value: true });
  		exports.fdir = void 0;
  		const builder_1 = requireBuilder();
  		Object.defineProperty(exports, "fdir", { enumerable: true, get: function () { return builder_1.Builder; } });
  		__exportStar(requireTypes(), exports); 
  	} (dist));
  	return dist;
  }

  var distExports = requireDist();

  const comma = ','.charCodeAt(0);
  const semicolon = ';'.charCodeAt(0);
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  const intToChar = new Uint8Array(64); // 64 possible chars.
  const charToInt = new Uint8Array(128); // z is 122 in ASCII
  for (let i = 0; i < chars.length; i++) {
      const c = chars.charCodeAt(i);
      intToChar[i] = c;
      charToInt[c] = i;
  }
  function encodeInteger(builder, num, relative) {
      let delta = num - relative;
      delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;
      do {
          let clamped = delta & 0b011111;
          delta >>>= 5;
          if (delta > 0)
              clamped |= 0b100000;
          builder.write(intToChar[clamped]);
      } while (delta > 0);
      return num;
  }

  const bufLength = 1024 * 16;
  // Provide a fallback for older environments.
  const td = typeof TextDecoder !== 'undefined'
      ? /* #__PURE__ */ new TextDecoder()
      : typeof Buffer !== 'undefined'
          ? {
              decode(buf) {
                  const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
                  return out.toString();
              },
          }
          : {
              decode(buf) {
                  let out = '';
                  for (let i = 0; i < buf.length; i++) {
                      out += String.fromCharCode(buf[i]);
                  }
                  return out;
              },
          };
  class StringWriter {
      constructor() {
          this.pos = 0;
          this.out = '';
          this.buffer = new Uint8Array(bufLength);
      }
      write(v) {
          const { buffer } = this;
          buffer[this.pos++] = v;
          if (this.pos === bufLength) {
              this.out += td.decode(buffer);
              this.pos = 0;
          }
      }
      flush() {
          const { buffer, out, pos } = this;
          return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
      }
  }
  function encode(decoded) {
      const writer = new StringWriter();
      let sourcesIndex = 0;
      let sourceLine = 0;
      let sourceColumn = 0;
      let namesIndex = 0;
      for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0)
              writer.write(semicolon);
          if (line.length === 0)
              continue;
          let genColumn = 0;
          for (let j = 0; j < line.length; j++) {
              const segment = line[j];
              if (j > 0)
                  writer.write(comma);
              genColumn = encodeInteger(writer, segment[0], genColumn);
              if (segment.length === 1)
                  continue;
              sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
              sourceLine = encodeInteger(writer, segment[2], sourceLine);
              sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
              if (segment.length === 4)
                  continue;
              namesIndex = encodeInteger(writer, segment[4], namesIndex);
          }
      }
      return writer.flush();
  }

  class BitSet {
  	constructor(arg) {
  		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
  	}

  	add(n) {
  		this.bits[n >> 5] |= 1 << (n & 31);
  	}

  	has(n) {
  		return !!(this.bits[n >> 5] & (1 << (n & 31)));
  	}
  }

  class Chunk {
  	constructor(start, end, content) {
  		this.start = start;
  		this.end = end;
  		this.original = content;

  		this.intro = '';
  		this.outro = '';

  		this.content = content;
  		this.storeName = false;
  		this.edited = false;

  		{
  			this.previous = null;
  			this.next = null;
  		}
  	}

  	appendLeft(content) {
  		this.outro += content;
  	}

  	appendRight(content) {
  		this.intro = this.intro + content;
  	}

  	clone() {
  		const chunk = new Chunk(this.start, this.end, this.original);

  		chunk.intro = this.intro;
  		chunk.outro = this.outro;
  		chunk.content = this.content;
  		chunk.storeName = this.storeName;
  		chunk.edited = this.edited;

  		return chunk;
  	}

  	contains(index) {
  		return this.start < index && index < this.end;
  	}

  	eachNext(fn) {
  		let chunk = this;
  		while (chunk) {
  			fn(chunk);
  			chunk = chunk.next;
  		}
  	}

  	eachPrevious(fn) {
  		let chunk = this;
  		while (chunk) {
  			fn(chunk);
  			chunk = chunk.previous;
  		}
  	}

  	edit(content, storeName, contentOnly) {
  		this.content = content;
  		if (!contentOnly) {
  			this.intro = '';
  			this.outro = '';
  		}
  		this.storeName = storeName;

  		this.edited = true;

  		return this;
  	}

  	prependLeft(content) {
  		this.outro = content + this.outro;
  	}

  	prependRight(content) {
  		this.intro = content + this.intro;
  	}

  	reset() {
  		this.intro = '';
  		this.outro = '';
  		if (this.edited) {
  			this.content = this.original;
  			this.storeName = false;
  			this.edited = false;
  		}
  	}

  	split(index) {
  		const sliceIndex = index - this.start;

  		const originalBefore = this.original.slice(0, sliceIndex);
  		const originalAfter = this.original.slice(sliceIndex);

  		this.original = originalBefore;

  		const newChunk = new Chunk(index, this.end, originalAfter);
  		newChunk.outro = this.outro;
  		this.outro = '';

  		this.end = index;

  		if (this.edited) {
  			// after split we should save the edit content record into the correct chunk
  			// to make sure sourcemap correct
  			// For example:
  			// '  test'.trim()
  			//     split   -> '  ' + 'test'
  			//   ✔️ edit    -> '' + 'test'
  			//   ✖️ edit    -> 'test' + '' 
  			// TODO is this block necessary?...
  			newChunk.edit('', false);
  			this.content = '';
  		} else {
  			this.content = originalBefore;
  		}

  		newChunk.next = this.next;
  		if (newChunk.next) newChunk.next.previous = newChunk;
  		newChunk.previous = this;
  		this.next = newChunk;

  		return newChunk;
  	}

  	toString() {
  		return this.intro + this.content + this.outro;
  	}

  	trimEnd(rx) {
  		this.outro = this.outro.replace(rx, '');
  		if (this.outro.length) return true;

  		const trimmed = this.content.replace(rx, '');

  		if (trimmed.length) {
  			if (trimmed !== this.content) {
  				this.split(this.start + trimmed.length).edit('', undefined, true);
  				if (this.edited) {
  					// save the change, if it has been edited
  					this.edit(trimmed, this.storeName, true);
  				}
  			}
  			return true;
  		} else {
  			this.edit('', undefined, true);

  			this.intro = this.intro.replace(rx, '');
  			if (this.intro.length) return true;
  		}
  	}

  	trimStart(rx) {
  		this.intro = this.intro.replace(rx, '');
  		if (this.intro.length) return true;

  		const trimmed = this.content.replace(rx, '');

  		if (trimmed.length) {
  			if (trimmed !== this.content) {
  				const newChunk = this.split(this.end - trimmed.length);
  				if (this.edited) {
  					// save the change, if it has been edited
  					newChunk.edit(trimmed, this.storeName, true);
  				}
  				this.edit('', undefined, true);
  			}
  			return true;
  		} else {
  			this.edit('', undefined, true);

  			this.outro = this.outro.replace(rx, '');
  			if (this.outro.length) return true;
  		}
  	}
  }

  function getBtoa() {
  	if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
  		return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
  	} else if (typeof Buffer === 'function') {
  		return (str) => Buffer.from(str, 'utf-8').toString('base64');
  	} else {
  		return () => {
  			throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
  		};
  	}
  }

  const btoa = /*#__PURE__*/ getBtoa();

  class SourceMap {
  	constructor(properties) {
  		this.version = 3;
  		this.file = properties.file;
  		this.sources = properties.sources;
  		this.sourcesContent = properties.sourcesContent;
  		this.names = properties.names;
  		this.mappings = encode(properties.mappings);
  		if (typeof properties.x_google_ignoreList !== 'undefined') {
  			this.x_google_ignoreList = properties.x_google_ignoreList;
  		}
  	}

  	toString() {
  		return JSON.stringify(this);
  	}

  	toUrl() {
  		return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
  	}
  }

  function guessIndent(code) {
  	const lines = code.split('\n');

  	const tabbed = lines.filter((line) => /^\t+/.test(line));
  	const spaced = lines.filter((line) => /^ {2,}/.test(line));

  	if (tabbed.length === 0 && spaced.length === 0) {
  		return null;
  	}

  	// More lines tabbed than spaced? Assume tabs, and
  	// default to tabs in the case of a tie (or nothing
  	// to go on)
  	if (tabbed.length >= spaced.length) {
  		return '\t';
  	}

  	// Otherwise, we need to guess the multiple
  	const min = spaced.reduce((previous, current) => {
  		const numSpaces = /^ +/.exec(current)[0].length;
  		return Math.min(numSpaces, previous);
  	}, Infinity);

  	return new Array(min + 1).join(' ');
  }

  function getRelativePath(from, to) {
  	const fromParts = from.split(/[/\\]/);
  	const toParts = to.split(/[/\\]/);

  	fromParts.pop(); // get dirname

  	while (fromParts[0] === toParts[0]) {
  		fromParts.shift();
  		toParts.shift();
  	}

  	if (fromParts.length) {
  		let i = fromParts.length;
  		while (i--) fromParts[i] = '..';
  	}

  	return fromParts.concat(toParts).join('/');
  }

  const toString = Object.prototype.toString;

  function isObject(thing) {
  	return toString.call(thing) === '[object Object]';
  }

  function getLocator(source) {
  	const originalLines = source.split('\n');
  	const lineOffsets = [];

  	for (let i = 0, pos = 0; i < originalLines.length; i++) {
  		lineOffsets.push(pos);
  		pos += originalLines[i].length + 1;
  	}

  	return function locate(index) {
  		let i = 0;
  		let j = lineOffsets.length;
  		while (i < j) {
  			const m = (i + j) >> 1;
  			if (index < lineOffsets[m]) {
  				j = m;
  			} else {
  				i = m + 1;
  			}
  		}
  		const line = i - 1;
  		const column = index - lineOffsets[line];
  		return { line, column };
  	};
  }

  const wordRegex = /\w/;

  class Mappings {
  	constructor(hires) {
  		this.hires = hires;
  		this.generatedCodeLine = 0;
  		this.generatedCodeColumn = 0;
  		this.raw = [];
  		this.rawSegments = this.raw[this.generatedCodeLine] = [];
  		this.pending = null;
  	}

  	addEdit(sourceIndex, content, loc, nameIndex) {
  		if (content.length) {
  			const contentLengthMinusOne = content.length - 1;
  			let contentLineEnd = content.indexOf('\n', 0);
  			let previousContentLineEnd = -1;
  			// Loop through each line in the content and add a segment, but stop if the last line is empty,
  			// else code afterwards would fill one line too many
  			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
  				const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
  				if (nameIndex >= 0) {
  					segment.push(nameIndex);
  				}
  				this.rawSegments.push(segment);

  				this.generatedCodeLine += 1;
  				this.raw[this.generatedCodeLine] = this.rawSegments = [];
  				this.generatedCodeColumn = 0;

  				previousContentLineEnd = contentLineEnd;
  				contentLineEnd = content.indexOf('\n', contentLineEnd + 1);
  			}

  			const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
  			if (nameIndex >= 0) {
  				segment.push(nameIndex);
  			}
  			this.rawSegments.push(segment);

  			this.advance(content.slice(previousContentLineEnd + 1));
  		} else if (this.pending) {
  			this.rawSegments.push(this.pending);
  			this.advance(content);
  		}

  		this.pending = null;
  	}

  	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
  		let originalCharIndex = chunk.start;
  		let first = true;
  		// when iterating each char, check if it's in a word boundary
  		let charInHiresBoundary = false;

  		while (originalCharIndex < chunk.end) {
  			if (original[originalCharIndex] === '\n') {
  				loc.line += 1;
  				loc.column = 0;
  				this.generatedCodeLine += 1;
  				this.raw[this.generatedCodeLine] = this.rawSegments = [];
  				this.generatedCodeColumn = 0;
  				first = true;
  			} else {
  				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
  					const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];

  					if (this.hires === 'boundary') {
  						// in hires "boundary", group segments per word boundary than per char
  						if (wordRegex.test(original[originalCharIndex])) {
  							// for first char in the boundary found, start the boundary by pushing a segment
  							if (!charInHiresBoundary) {
  								this.rawSegments.push(segment);
  								charInHiresBoundary = true;
  							}
  						} else {
  							// for non-word char, end the boundary by pushing a segment
  							this.rawSegments.push(segment);
  							charInHiresBoundary = false;
  						}
  					} else {
  						this.rawSegments.push(segment);
  					}
  				}

  				loc.column += 1;
  				this.generatedCodeColumn += 1;
  				first = false;
  			}

  			originalCharIndex += 1;
  		}

  		this.pending = null;
  	}

  	advance(str) {
  		if (!str) return;

  		const lines = str.split('\n');

  		if (lines.length > 1) {
  			for (let i = 0; i < lines.length - 1; i++) {
  				this.generatedCodeLine++;
  				this.raw[this.generatedCodeLine] = this.rawSegments = [];
  			}
  			this.generatedCodeColumn = 0;
  		}

  		this.generatedCodeColumn += lines[lines.length - 1].length;
  	}
  }

  const n = '\n';

  const warned = {
  	insertLeft: false,
  	insertRight: false,
  	storeName: false,
  };

  class MagicString {
  	constructor(string, options = {}) {
  		const chunk = new Chunk(0, string.length, string);

  		Object.defineProperties(this, {
  			original: { writable: true, value: string },
  			outro: { writable: true, value: '' },
  			intro: { writable: true, value: '' },
  			firstChunk: { writable: true, value: chunk },
  			lastChunk: { writable: true, value: chunk },
  			lastSearchedChunk: { writable: true, value: chunk },
  			byStart: { writable: true, value: {} },
  			byEnd: { writable: true, value: {} },
  			filename: { writable: true, value: options.filename },
  			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
  			sourcemapLocations: { writable: true, value: new BitSet() },
  			storedNames: { writable: true, value: {} },
  			indentStr: { writable: true, value: undefined },
  			ignoreList: { writable: true, value: options.ignoreList },
  		});

  		this.byStart[0] = chunk;
  		this.byEnd[string.length] = chunk;
  	}

  	addSourcemapLocation(char) {
  		this.sourcemapLocations.add(char);
  	}

  	append(content) {
  		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

  		this.outro += content;
  		return this;
  	}

  	appendLeft(index, content) {
  		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

  		this._split(index);

  		const chunk = this.byEnd[index];

  		if (chunk) {
  			chunk.appendLeft(content);
  		} else {
  			this.intro += content;
  		}
  		return this;
  	}

  	appendRight(index, content) {
  		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

  		this._split(index);

  		const chunk = this.byStart[index];

  		if (chunk) {
  			chunk.appendRight(content);
  		} else {
  			this.outro += content;
  		}
  		return this;
  	}

  	clone() {
  		const cloned = new MagicString(this.original, { filename: this.filename });

  		let originalChunk = this.firstChunk;
  		let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

  		while (originalChunk) {
  			cloned.byStart[clonedChunk.start] = clonedChunk;
  			cloned.byEnd[clonedChunk.end] = clonedChunk;

  			const nextOriginalChunk = originalChunk.next;
  			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

  			if (nextClonedChunk) {
  				clonedChunk.next = nextClonedChunk;
  				nextClonedChunk.previous = clonedChunk;

  				clonedChunk = nextClonedChunk;
  			}

  			originalChunk = nextOriginalChunk;
  		}

  		cloned.lastChunk = clonedChunk;

  		if (this.indentExclusionRanges) {
  			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
  		}

  		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

  		cloned.intro = this.intro;
  		cloned.outro = this.outro;

  		return cloned;
  	}

  	generateDecodedMap(options) {
  		options = options || {};

  		const sourceIndex = 0;
  		const names = Object.keys(this.storedNames);
  		const mappings = new Mappings(options.hires);

  		const locate = getLocator(this.original);

  		if (this.intro) {
  			mappings.advance(this.intro);
  		}

  		this.firstChunk.eachNext((chunk) => {
  			const loc = locate(chunk.start);

  			if (chunk.intro.length) mappings.advance(chunk.intro);

  			if (chunk.edited) {
  				mappings.addEdit(
  					sourceIndex,
  					chunk.content,
  					loc,
  					chunk.storeName ? names.indexOf(chunk.original) : -1,
  				);
  			} else {
  				mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
  			}

  			if (chunk.outro.length) mappings.advance(chunk.outro);
  		});

  		return {
  			file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
  			sources: [
  				options.source ? getRelativePath(options.file || '', options.source) : options.file || '',
  			],
  			sourcesContent: options.includeContent ? [this.original] : undefined,
  			names,
  			mappings: mappings.raw,
  			x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,
  		};
  	}

  	generateMap(options) {
  		return new SourceMap(this.generateDecodedMap(options));
  	}

  	_ensureindentStr() {
  		if (this.indentStr === undefined) {
  			this.indentStr = guessIndent(this.original);
  		}
  	}

  	_getRawIndentString() {
  		this._ensureindentStr();
  		return this.indentStr;
  	}

  	getIndentString() {
  		this._ensureindentStr();
  		return this.indentStr === null ? '\t' : this.indentStr;
  	}

  	indent(indentStr, options) {
  		const pattern = /^[^\r\n]/gm;

  		if (isObject(indentStr)) {
  			options = indentStr;
  			indentStr = undefined;
  		}

  		if (indentStr === undefined) {
  			this._ensureindentStr();
  			indentStr = this.indentStr || '\t';
  		}

  		if (indentStr === '') return this; // noop

  		options = options || {};

  		// Process exclusion ranges
  		const isExcluded = {};

  		if (options.exclude) {
  			const exclusions =
  				typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
  			exclusions.forEach((exclusion) => {
  				for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
  					isExcluded[i] = true;
  				}
  			});
  		}

  		let shouldIndentNextCharacter = options.indentStart !== false;
  		const replacer = (match) => {
  			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
  			shouldIndentNextCharacter = true;
  			return match;
  		};

  		this.intro = this.intro.replace(pattern, replacer);

  		let charIndex = 0;
  		let chunk = this.firstChunk;

  		while (chunk) {
  			const end = chunk.end;

  			if (chunk.edited) {
  				if (!isExcluded[charIndex]) {
  					chunk.content = chunk.content.replace(pattern, replacer);

  					if (chunk.content.length) {
  						shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
  					}
  				}
  			} else {
  				charIndex = chunk.start;

  				while (charIndex < end) {
  					if (!isExcluded[charIndex]) {
  						const char = this.original[charIndex];

  						if (char === '\n') {
  							shouldIndentNextCharacter = true;
  						} else if (char !== '\r' && shouldIndentNextCharacter) {
  							shouldIndentNextCharacter = false;

  							if (charIndex === chunk.start) {
  								chunk.prependRight(indentStr);
  							} else {
  								this._splitChunk(chunk, charIndex);
  								chunk = chunk.next;
  								chunk.prependRight(indentStr);
  							}
  						}
  					}

  					charIndex += 1;
  				}
  			}

  			charIndex = chunk.end;
  			chunk = chunk.next;
  		}

  		this.outro = this.outro.replace(pattern, replacer);

  		return this;
  	}

  	insert() {
  		throw new Error(
  			'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',
  		);
  	}

  	insertLeft(index, content) {
  		if (!warned.insertLeft) {
  			console.warn(
  				'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',
  			); // eslint-disable-line no-console
  			warned.insertLeft = true;
  		}

  		return this.appendLeft(index, content);
  	}

  	insertRight(index, content) {
  		if (!warned.insertRight) {
  			console.warn(
  				'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',
  			); // eslint-disable-line no-console
  			warned.insertRight = true;
  		}

  		return this.prependRight(index, content);
  	}

  	move(start, end, index) {
  		if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');

  		this._split(start);
  		this._split(end);
  		this._split(index);

  		const first = this.byStart[start];
  		const last = this.byEnd[end];

  		const oldLeft = first.previous;
  		const oldRight = last.next;

  		const newRight = this.byStart[index];
  		if (!newRight && last === this.lastChunk) return this;
  		const newLeft = newRight ? newRight.previous : this.lastChunk;

  		if (oldLeft) oldLeft.next = oldRight;
  		if (oldRight) oldRight.previous = oldLeft;

  		if (newLeft) newLeft.next = first;
  		if (newRight) newRight.previous = last;

  		if (!first.previous) this.firstChunk = last.next;
  		if (!last.next) {
  			this.lastChunk = first.previous;
  			this.lastChunk.next = null;
  		}

  		first.previous = newLeft;
  		last.next = newRight || null;

  		if (!newLeft) this.firstChunk = first;
  		if (!newRight) this.lastChunk = last;
  		return this;
  	}

  	overwrite(start, end, content, options) {
  		options = options || {};
  		return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
  	}

  	update(start, end, content, options) {
  		if (typeof content !== 'string') throw new TypeError('replacement content must be a string');

  		if (this.original.length !== 0) {
  			while (start < 0) start += this.original.length;
  			while (end < 0) end += this.original.length;
  		}

  		if (end > this.original.length) throw new Error('end is out of bounds');
  		if (start === end)
  			throw new Error(
  				'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',
  			);

  		this._split(start);
  		this._split(end);

  		if (options === true) {
  			if (!warned.storeName) {
  				console.warn(
  					'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',
  				); // eslint-disable-line no-console
  				warned.storeName = true;
  			}

  			options = { storeName: true };
  		}
  		const storeName = options !== undefined ? options.storeName : false;
  		const overwrite = options !== undefined ? options.overwrite : false;

  		if (storeName) {
  			const original = this.original.slice(start, end);
  			Object.defineProperty(this.storedNames, original, {
  				writable: true,
  				value: true,
  				enumerable: true,
  			});
  		}

  		const first = this.byStart[start];
  		const last = this.byEnd[end];

  		if (first) {
  			let chunk = first;
  			while (chunk !== last) {
  				if (chunk.next !== this.byStart[chunk.end]) {
  					throw new Error('Cannot overwrite across a split point');
  				}
  				chunk = chunk.next;
  				chunk.edit('', false);
  			}

  			first.edit(content, storeName, !overwrite);
  		} else {
  			// must be inserting at the end
  			const newChunk = new Chunk(start, end, '').edit(content, storeName);

  			// TODO last chunk in the array may not be the last chunk, if it's moved...
  			last.next = newChunk;
  			newChunk.previous = last;
  		}
  		return this;
  	}

  	prepend(content) {
  		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

  		this.intro = content + this.intro;
  		return this;
  	}

  	prependLeft(index, content) {
  		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

  		this._split(index);

  		const chunk = this.byEnd[index];

  		if (chunk) {
  			chunk.prependLeft(content);
  		} else {
  			this.intro = content + this.intro;
  		}
  		return this;
  	}

  	prependRight(index, content) {
  		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

  		this._split(index);

  		const chunk = this.byStart[index];

  		if (chunk) {
  			chunk.prependRight(content);
  		} else {
  			this.outro = content + this.outro;
  		}
  		return this;
  	}

  	remove(start, end) {
  		if (this.original.length !== 0) {
  			while (start < 0) start += this.original.length;
  			while (end < 0) end += this.original.length;
  		}

  		if (start === end) return this;

  		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
  		if (start > end) throw new Error('end must be greater than start');

  		this._split(start);
  		this._split(end);

  		let chunk = this.byStart[start];

  		while (chunk) {
  			chunk.intro = '';
  			chunk.outro = '';
  			chunk.edit('');

  			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
  		}
  		return this;
  	}

  	reset(start, end) {
  		if (this.original.length !== 0) {
  			while (start < 0) start += this.original.length;
  			while (end < 0) end += this.original.length;
  		}

  		if (start === end) return this;

  		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
  		if (start > end) throw new Error('end must be greater than start');

  		this._split(start);
  		this._split(end);

  		let chunk = this.byStart[start];

  		while (chunk) {
  			chunk.reset();

  			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
  		}
  		return this;
  	}

  	lastChar() {
  		if (this.outro.length) return this.outro[this.outro.length - 1];
  		let chunk = this.lastChunk;
  		do {
  			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
  			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
  			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
  		} while ((chunk = chunk.previous));
  		if (this.intro.length) return this.intro[this.intro.length - 1];
  		return '';
  	}

  	lastLine() {
  		let lineIndex = this.outro.lastIndexOf(n);
  		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
  		let lineStr = this.outro;
  		let chunk = this.lastChunk;
  		do {
  			if (chunk.outro.length > 0) {
  				lineIndex = chunk.outro.lastIndexOf(n);
  				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
  				lineStr = chunk.outro + lineStr;
  			}

  			if (chunk.content.length > 0) {
  				lineIndex = chunk.content.lastIndexOf(n);
  				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
  				lineStr = chunk.content + lineStr;
  			}

  			if (chunk.intro.length > 0) {
  				lineIndex = chunk.intro.lastIndexOf(n);
  				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
  				lineStr = chunk.intro + lineStr;
  			}
  		} while ((chunk = chunk.previous));
  		lineIndex = this.intro.lastIndexOf(n);
  		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
  		return this.intro + lineStr;
  	}

  	slice(start = 0, end = this.original.length) {
  		if (this.original.length !== 0) {
  			while (start < 0) start += this.original.length;
  			while (end < 0) end += this.original.length;
  		}

  		let result = '';

  		// find start chunk
  		let chunk = this.firstChunk;
  		while (chunk && (chunk.start > start || chunk.end <= start)) {
  			// found end chunk before start
  			if (chunk.start < end && chunk.end >= end) {
  				return result;
  			}

  			chunk = chunk.next;
  		}

  		if (chunk && chunk.edited && chunk.start !== start)
  			throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);

  		const startChunk = chunk;
  		while (chunk) {
  			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
  				result += chunk.intro;
  			}

  			const containsEnd = chunk.start < end && chunk.end >= end;
  			if (containsEnd && chunk.edited && chunk.end !== end)
  				throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);

  			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
  			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

  			result += chunk.content.slice(sliceStart, sliceEnd);

  			if (chunk.outro && (!containsEnd || chunk.end === end)) {
  				result += chunk.outro;
  			}

  			if (containsEnd) {
  				break;
  			}

  			chunk = chunk.next;
  		}

  		return result;
  	}

  	// TODO deprecate this? not really very useful
  	snip(start, end) {
  		const clone = this.clone();
  		clone.remove(0, start);
  		clone.remove(end, clone.original.length);

  		return clone;
  	}

  	_split(index) {
  		if (this.byStart[index] || this.byEnd[index]) return;

  		let chunk = this.lastSearchedChunk;
  		const searchForward = index > chunk.end;

  		while (chunk) {
  			if (chunk.contains(index)) return this._splitChunk(chunk, index);

  			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
  		}
  	}

  	_splitChunk(chunk, index) {
  		if (chunk.edited && chunk.content.length) {
  			// zero-length edited chunks are a special case (overlapping replacements)
  			const loc = getLocator(this.original)(index);
  			throw new Error(
  				`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`,
  			);
  		}

  		const newChunk = chunk.split(index);

  		this.byEnd[index] = chunk;
  		this.byStart[index] = newChunk;
  		this.byEnd[newChunk.end] = newChunk;

  		if (chunk === this.lastChunk) this.lastChunk = newChunk;

  		this.lastSearchedChunk = chunk;
  		return true;
  	}

  	toString() {
  		let str = this.intro;

  		let chunk = this.firstChunk;
  		while (chunk) {
  			str += chunk.toString();
  			chunk = chunk.next;
  		}

  		return str + this.outro;
  	}

  	isEmpty() {
  		let chunk = this.firstChunk;
  		do {
  			if (
  				(chunk.intro.length && chunk.intro.trim()) ||
  				(chunk.content.length && chunk.content.trim()) ||
  				(chunk.outro.length && chunk.outro.trim())
  			)
  				return false;
  		} while ((chunk = chunk.next));
  		return true;
  	}

  	length() {
  		let chunk = this.firstChunk;
  		let length = 0;
  		do {
  			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
  		} while ((chunk = chunk.next));
  		return length;
  	}

  	trimLines() {
  		return this.trim('[\\r\\n]');
  	}

  	trim(charType) {
  		return this.trimStart(charType).trimEnd(charType);
  	}

  	trimEndAborted(charType) {
  		const rx = new RegExp((charType || '\\s') + '+$');

  		this.outro = this.outro.replace(rx, '');
  		if (this.outro.length) return true;

  		let chunk = this.lastChunk;

  		do {
  			const end = chunk.end;
  			const aborted = chunk.trimEnd(rx);

  			// if chunk was trimmed, we have a new lastChunk
  			if (chunk.end !== end) {
  				if (this.lastChunk === chunk) {
  					this.lastChunk = chunk.next;
  				}

  				this.byEnd[chunk.end] = chunk;
  				this.byStart[chunk.next.start] = chunk.next;
  				this.byEnd[chunk.next.end] = chunk.next;
  			}

  			if (aborted) return true;
  			chunk = chunk.previous;
  		} while (chunk);

  		return false;
  	}

  	trimEnd(charType) {
  		this.trimEndAborted(charType);
  		return this;
  	}
  	trimStartAborted(charType) {
  		const rx = new RegExp('^' + (charType || '\\s') + '+');

  		this.intro = this.intro.replace(rx, '');
  		if (this.intro.length) return true;

  		let chunk = this.firstChunk;

  		do {
  			const end = chunk.end;
  			const aborted = chunk.trimStart(rx);

  			if (chunk.end !== end) {
  				// special case...
  				if (chunk === this.lastChunk) this.lastChunk = chunk.next;

  				this.byEnd[chunk.end] = chunk;
  				this.byStart[chunk.next.start] = chunk.next;
  				this.byEnd[chunk.next.end] = chunk.next;
  			}

  			if (aborted) return true;
  			chunk = chunk.next;
  		} while (chunk);

  		return false;
  	}

  	trimStart(charType) {
  		this.trimStartAborted(charType);
  		return this;
  	}

  	hasChanged() {
  		return this.original !== this.toString();
  	}

  	_replaceRegexp(searchValue, replacement) {
  		function getReplacement(match, str) {
  			if (typeof replacement === 'string') {
  				return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
  					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
  					if (i === '$') return '$';
  					if (i === '&') return match[0];
  					const num = +i;
  					if (num < match.length) return match[+i];
  					return `$${i}`;
  				});
  			} else {
  				return replacement(...match, match.index, str, match.groups);
  			}
  		}
  		function matchAll(re, str) {
  			let match;
  			const matches = [];
  			while ((match = re.exec(str))) {
  				matches.push(match);
  			}
  			return matches;
  		}
  		if (searchValue.global) {
  			const matches = matchAll(searchValue, this.original);
  			matches.forEach((match) => {
  				if (match.index != null) {
  					const replacement = getReplacement(match, this.original);
  					if (replacement !== match[0]) {
  						this.overwrite(
  							match.index,
  							match.index + match[0].length,
  							replacement
  						);
  					}
  				}
  			});
  		} else {
  			const match = this.original.match(searchValue);
  			if (match && match.index != null) {
  				const replacement = getReplacement(match, this.original);
  				if (replacement !== match[0]) {
  					this.overwrite(
  						match.index,
  						match.index + match[0].length,
  						replacement
  					);
  				}
  			}
  		}
  		return this;
  	}

  	_replaceString(string, replacement) {
  		const { original } = this;
  		const index = original.indexOf(string);

  		if (index !== -1) {
  			this.overwrite(index, index + string.length, replacement);
  		}

  		return this;
  	}

  	replace(searchValue, replacement) {
  		if (typeof searchValue === 'string') {
  			return this._replaceString(searchValue, replacement);
  		}

  		return this._replaceRegexp(searchValue, replacement);
  	}

  	_replaceAllString(string, replacement) {
  		const { original } = this;
  		const stringLength = string.length;
  		for (
  			let index = original.indexOf(string);
  			index !== -1;
  			index = original.indexOf(string, index + stringLength)
  		) {
  			const previous = original.slice(index, index + stringLength);
  			if (previous !== replacement)
  				this.overwrite(index, index + stringLength, replacement);
  		}

  		return this;
  	}

  	replaceAll(searchValue, replacement) {
  		if (typeof searchValue === 'string') {
  			return this._replaceAllString(searchValue, replacement);
  		}

  		if (!searchValue.global) {
  			throw new TypeError(
  				'MagicString.prototype.replaceAll called with a non-global RegExp argument',
  			);
  		}

  		return this._replaceRegexp(searchValue, replacement);
  	}
  }

  function isReference(node, parent) {
      if (node.type === 'MemberExpression') {
          return !node.computed && isReference(node.object, node);
      }
      if (node.type === 'Identifier') {
          if (!parent)
              return true;
          switch (parent.type) {
              // disregard `bar` in `foo.bar`
              case 'MemberExpression': return parent.computed || node === parent.object;
              // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`
              case 'MethodDefinition': return parent.computed;
              // disregard the `foo` in `class {foo=bar}` but keep it in `class {[foo]=bar}` and `class {bar=foo}`
              case 'FieldDefinition': return parent.computed || node === parent.value;
              // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
              case 'Property': return parent.computed || node === parent.value;
              // disregard the `bar` in `export { foo as bar }` or
              // the foo in `import { foo as bar }`
              case 'ExportSpecifier':
              case 'ImportSpecifier': return node === parent.local;
              // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`
              case 'LabeledStatement':
              case 'BreakStatement':
              case 'ContinueStatement': return false;
              default: return true;
          }
      }
      return false;
  }

  var version = "28.0.1";
  var peerDependencies = {
  	rollup: "^2.68.0||^3.0.0||^4.0.0"
  };

  function tryParse(parse, code, id) {
    try {
      return parse(code, { allowReturnOutsideFunction: true });
    } catch (err) {
      err.message += ` in ${id}`;
      throw err;
    }
  }

  const firstpassGlobal = /\b(?:require|module|exports|global)\b/;

  const firstpassNoGlobal = /\b(?:require|module|exports)\b/;

  function hasCjsKeywords(code, ignoreGlobal) {
    const firstpass = ignoreGlobal ? firstpassNoGlobal : firstpassGlobal;
    return firstpass.test(code);
  }

  /* eslint-disable no-underscore-dangle */


  function analyzeTopLevelStatements(parse, code, id) {
    const ast = tryParse(parse, code, id);

    let isEsModule = false;
    let hasDefaultExport = false;
    let hasNamedExports = false;

    for (const node of ast.body) {
      switch (node.type) {
        case 'ExportDefaultDeclaration':
          isEsModule = true;
          hasDefaultExport = true;
          break;
        case 'ExportNamedDeclaration':
          isEsModule = true;
          if (node.declaration) {
            hasNamedExports = true;
          } else {
            for (const specifier of node.specifiers) {
              if (specifier.exported.name === 'default') {
                hasDefaultExport = true;
              } else {
                hasNamedExports = true;
              }
            }
          }
          break;
        case 'ExportAllDeclaration':
          isEsModule = true;
          if (node.exported && node.exported.name === 'default') {
            hasDefaultExport = true;
          } else {
            hasNamedExports = true;
          }
          break;
        case 'ImportDeclaration':
          isEsModule = true;
          break;
      }
    }

    return { isEsModule, hasDefaultExport, hasNamedExports, ast };
  }

  /* eslint-disable import/prefer-default-export */


  function deconflict(scopes, globals, identifier) {
    let i = 1;
    let deconflicted = makeLegalIdentifier(identifier);
    const hasConflicts = () =>
      scopes.some((scope) => scope.contains(deconflicted)) || globals.has(deconflicted);

    while (hasConflicts()) {
      deconflicted = makeLegalIdentifier(`${identifier}_${i}`);
      i += 1;
    }

    for (const scope of scopes) {
      scope.declarations[deconflicted] = true;
    }

    return deconflicted;
  }

  function getName(id) {
    const name = makeLegalIdentifier(require$$0.basename(id, require$$0.extname(id)));
    if (name !== 'index') {
      return name;
    }
    return makeLegalIdentifier(require$$0.basename(require$$0.dirname(id)));
  }

  function normalizePathSlashes(path) {
    return path.replace(/\\/g, '/');
  }

  const getVirtualPathForDynamicRequirePath = (path, commonDir) =>
    `/${normalizePathSlashes(require$$0.relative(commonDir, path))}`;

  function capitalize(name) {
    return name[0].toUpperCase() + name.slice(1);
  }

  function getStrictRequiresFilter({ strictRequires }) {
    switch (strictRequires) {
      // eslint-disable-next-line no-undefined
      case undefined:
      case true:
        return { strictRequiresFilter: () => true, detectCyclesAndConditional: false };
      case 'auto':
      case 'debug':
      case null:
        return { strictRequiresFilter: () => false, detectCyclesAndConditional: true };
      case false:
        return { strictRequiresFilter: () => false, detectCyclesAndConditional: false };
      default:
        if (typeof strictRequires === 'string' || Array.isArray(strictRequires)) {
          return {
            strictRequiresFilter: createFilter(strictRequires),
            detectCyclesAndConditional: false
          };
        }
        throw new Error('Unexpected value for "strictRequires" option.');
    }
  }

  function getPackageEntryPoint(dirPath) {
    let entryPoint = 'index.js';

    try {
      if (require$$0$1.existsSync(require$$0.join(dirPath, 'package.json'))) {
        entryPoint =
          JSON.parse(require$$0$1.readFileSync(require$$0.join(dirPath, 'package.json'), { encoding: 'utf8' })).main ||
          entryPoint;
      }
    } catch (ignored) {
      // ignored
    }

    return entryPoint;
  }

  function isDirectory(path) {
    try {
      if (require$$0$1.statSync(path).isDirectory()) return true;
    } catch (ignored) {
      // Nothing to do here
    }
    return false;
  }

  function getDynamicRequireModules(patterns, dynamicRequireRoot) {
    const dynamicRequireModules = new Map();
    const dirNames = new Set();
    for (const pattern of !patterns || Array.isArray(patterns) ? patterns || [] : [patterns]) {
      const isNegated = pattern.startsWith('!');
      const modifyMap = (targetPath, resolvedPath) =>
        isNegated
          ? dynamicRequireModules.delete(targetPath)
          : dynamicRequireModules.set(targetPath, resolvedPath);
      // eslint-disable-next-line new-cap
      for (const path of new distExports.fdir()
        .withBasePath()
        .withDirs()
        .glob(isNegated ? pattern.substr(1) : pattern)
        .crawl()
        .sync()
        .sort((a, b) => a.localeCompare(b, 'en'))) {
        const resolvedPath = require$$0.resolve(path);
        const requirePath = normalizePathSlashes(resolvedPath);
        if (isDirectory(resolvedPath)) {
          dirNames.add(resolvedPath);
          const modulePath = require$$0.resolve(require$$0.join(resolvedPath, getPackageEntryPoint(path)));
          modifyMap(requirePath, modulePath);
          modifyMap(normalizePathSlashes(modulePath), modulePath);
        } else {
          dirNames.add(require$$0.dirname(resolvedPath));
          modifyMap(requirePath, resolvedPath);
        }
      }
    }
    return {
      commonDir: dirNames.size ? getCommonDir([...dirNames, dynamicRequireRoot]) : null,
      dynamicRequireModules
    };
  }

  const FAILED_REQUIRE_ERROR = `throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');`;

  const COMMONJS_REQUIRE_EXPORT = 'commonjsRequire';
  const CREATE_COMMONJS_REQUIRE_EXPORT = 'createCommonjsRequire';

  function getDynamicModuleRegistry(
    isDynamicRequireModulesEnabled,
    dynamicRequireModules,
    commonDir,
    ignoreDynamicRequires
  ) {
    if (!isDynamicRequireModulesEnabled) {
      return `export function ${COMMONJS_REQUIRE_EXPORT}(path) {
	${FAILED_REQUIRE_ERROR}
}`;
    }
    const dynamicModuleImports = [...dynamicRequireModules.values()]
      .map(
        (id, index) =>
          `import ${
          id.endsWith('.json') ? `json${index}` : `{ __require as require${index} }`
        } from ${JSON.stringify(id)};`
      )
      .join('\n');
    const dynamicModuleProps = [...dynamicRequireModules.keys()]
      .map(
        (id, index) =>
          `\t\t${JSON.stringify(getVirtualPathForDynamicRequirePath(id, commonDir))}: ${
          id.endsWith('.json') ? `function () { return json${index}; }` : `require${index}`
        }`
      )
      .join(',\n');
    return `${dynamicModuleImports}

var dynamicModules;

function getDynamicModules() {
	return dynamicModules || (dynamicModules = {
${dynamicModuleProps}
	});
}

export function ${CREATE_COMMONJS_REQUIRE_EXPORT}(originalModuleDir) {
	function handleRequire(path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return getDynamicModules()[resolvedPath]();
		}
		${ignoreDynamicRequires ? 'return require(path);' : FAILED_REQUIRE_ERROR}
	}
	handleRequire.resolve = function (path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return resolvedPath;
		}
		return require.resolve(path);
	}
	return handleRequire;
}

function commonjsResolve (path, originalModuleDir) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '';
	}
	var modules = getDynamicModules();
	var checkedExtensions = ['', '.js', '.json'];
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = normalize(originalModuleDir + '/' + path);
		} else {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < checkedExtensions.length; extensionIndex++) {
			var resolvedPath = relPath + checkedExtensions[extensionIndex];
			if (modules[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\\\')) return false;
	return true;
}

function normalize (path) {
	path = path.replace(/\\\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/') path = '/' + path;
	else if (path.length === 0) path = '.';
	return path;
}`;
  }

  const isWrappedId = (id, suffix) => id.endsWith(suffix);
  const wrapId = (id, suffix) => `\0${id}${suffix}`;
  const unwrapId = (wrappedId, suffix) => wrappedId.slice(1, -suffix.length);

  // A proxy module when a module is required from non-wrapped CommonJS. Is different for ESM and CommonJS requires.
  const PROXY_SUFFIX = '?commonjs-proxy';
  // Indicates that a required module is wrapped commonjs and needs special handling.
  const WRAPPED_SUFFIX = '?commonjs-wrapped';
  // Indicates that a required module is external
  const EXTERNAL_SUFFIX = '?commonjs-external';
  // A helper module that contains the exports object of a module
  const EXPORTS_SUFFIX = '?commonjs-exports';
  // A helper module that contains the module object of a module, e.g. when module.exports is reassigned
  const MODULE_SUFFIX = '?commonjs-module';
  // A special proxy for CommonJS entry points
  const ENTRY_SUFFIX = '?commonjs-entry';
  // A proxy when wrapped ESM is required from CommonJS
  const ES_IMPORT_SUFFIX = '?commonjs-es-import';

  const DYNAMIC_MODULES_ID = '\0commonjs-dynamic-modules';
  const HELPERS_ID = '\0commonjsHelpers.js';

  const IS_WRAPPED_COMMONJS = 'withRequireFunction';

  // `x['default']` is used instead of `x.default` for backward compatibility with ES3 browsers.
  // Minifiers like uglify will usually transpile it back if compatibility with ES3 is not enabled.
  // This could be improved by inspecting Rollup's "generatedCode" option

  const HELPERS = `
export var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

export function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

export function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

export function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

export function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}
`;

  function getHelpersModule() {
    return HELPERS;
  }

  function getUnknownRequireProxy(id, requireReturnsDefault) {
    if (requireReturnsDefault === true || id.endsWith('.json')) {
      return `export { default } from ${JSON.stringify(id)};`;
    }
    const name = getName(id);
    const exported =
      requireReturnsDefault === 'auto'
        ? `import { getDefaultExportFromNamespaceIfNotNamed } from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(${name});`
        : requireReturnsDefault === 'preferred'
        ? `import { getDefaultExportFromNamespaceIfPresent } from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfPresent(${name});`
        : !requireReturnsDefault
        ? `import { getAugmentedNamespace } from "${HELPERS_ID}"; export default /*@__PURE__*/getAugmentedNamespace(${name});`
        : `export default ${name};`;
    return `import * as ${name} from ${JSON.stringify(id)}; ${exported}`;
  }

  async function getStaticRequireProxy(id, requireReturnsDefault, loadModule) {
    const name = getName(id);
    const {
      meta: { commonjs: commonjsMeta }
    } = await loadModule({ id });
    if (!commonjsMeta) {
      return getUnknownRequireProxy(id, requireReturnsDefault);
    }
    if (commonjsMeta.isCommonJS) {
      return `export { __moduleExports as default } from ${JSON.stringify(id)};`;
    }
    if (!requireReturnsDefault) {
      return `import { getAugmentedNamespace } from "${HELPERS_ID}"; import * as ${name} from ${JSON.stringify(
      id
    )}; export default /*@__PURE__*/getAugmentedNamespace(${name});`;
    }
    if (
      requireReturnsDefault !== true &&
      (requireReturnsDefault === 'namespace' ||
        !commonjsMeta.hasDefaultExport ||
        (requireReturnsDefault === 'auto' && commonjsMeta.hasNamedExports))
    ) {
      return `import * as ${name} from ${JSON.stringify(id)}; export default ${name};`;
    }
    return `export { default } from ${JSON.stringify(id)};`;
  }

  function getEntryProxy(id, defaultIsModuleExports, getModuleInfo, shebang) {
    const {
      meta: { commonjs: commonjsMeta },
      hasDefaultExport
    } = getModuleInfo(id);
    if (!commonjsMeta || commonjsMeta.isCommonJS !== IS_WRAPPED_COMMONJS) {
      const stringifiedId = JSON.stringify(id);
      let code = `export * from ${stringifiedId};`;
      if (hasDefaultExport) {
        code += `export { default } from ${stringifiedId};`;
      }
      return shebang + code;
    }
    const result = getEsImportProxy(id, defaultIsModuleExports, true);
    return {
      ...result,
      code: shebang + result.code
    };
  }

  function getEsImportProxy(id, defaultIsModuleExports, moduleSideEffects) {
    const name = getName(id);
    const exportsName = `${name}Exports`;
    const requireModule = `require${capitalize(name)}`;
    let code =
      `import { getDefaultExportFromCjs } from "${HELPERS_ID}";\n` +
      `import { __require as ${requireModule} } from ${JSON.stringify(id)};\n` +
      `var ${exportsName} = ${moduleSideEffects ? '' : '/*@__PURE__*/ '}${requireModule}();\n` +
      `export { ${exportsName} as __moduleExports };`;
    if (defaultIsModuleExports === true) {
      code += `\nexport { ${exportsName} as default };`;
    } else if (defaultIsModuleExports === false) {
      code += `\nexport default ${exportsName}.default;`;
    } else {
      code += `\nexport default /*@__PURE__*/getDefaultExportFromCjs(${exportsName});`;
    }
    return {
      code,
      syntheticNamedExports: '__moduleExports'
    };
  }

  /* eslint-disable no-param-reassign, no-undefined */


  function getCandidatesForExtension(resolved, extension) {
    return [resolved + extension, `${resolved}${require$$0.sep}index${extension}`];
  }

  function getCandidates(resolved, extensions) {
    return extensions.reduce(
      (paths, extension) => paths.concat(getCandidatesForExtension(resolved, extension)),
      [resolved]
    );
  }

  function resolveExtensions(importee, importer, extensions) {
    // not our problem
    if (importee[0] !== '.' || !importer) return undefined;

    const resolved = require$$0.resolve(require$$0.dirname(importer), importee);
    const candidates = getCandidates(resolved, extensions);

    for (let i = 0; i < candidates.length; i += 1) {
      try {
        const stats = require$$0$1.statSync(candidates[i]);
        if (stats.isFile()) return { id: candidates[i] };
      } catch (err) {
        /* noop */
      }
    }

    return undefined;
  }

  function getResolveId(extensions, isPossibleCjsId) {
    const currentlyResolving = new Map();

    return {
      /**
       * This is a Maps of importers to Sets of require sources being resolved at
       * the moment by resolveRequireSourcesAndUpdateMeta
       */
      currentlyResolving,
      async resolveId(importee, importer, resolveOptions) {
        const customOptions = resolveOptions.custom;
        // All logic below is specific to ES imports.
        // Also, if we do not skip this logic for requires that are resolved while
        // transforming a commonjs file, it can easily lead to deadlocks.
        if (customOptions?.['node-resolve']?.isRequire) {
          return null;
        }
        const currentlyResolvingForParent = currentlyResolving.get(importer);
        if (currentlyResolvingForParent && currentlyResolvingForParent.has(importee)) {
          this.warn({
            code: 'THIS_RESOLVE_WITHOUT_OPTIONS',
            message:
              'It appears a plugin has implemented a "resolveId" hook that uses "this.resolve" without forwarding the third "options" parameter of "resolveId". This is problematic as it can lead to wrong module resolutions especially for the node-resolve plugin and in certain cases cause early exit errors for the commonjs plugin.\nIn rare cases, this warning can appear if the same file is both imported and required from the same mixed ES/CommonJS module, in which case it can be ignored.',
            url: 'https://rollupjs.org/guide/en/#resolveid'
          });
          return null;
        }

        if (isWrappedId(importee, WRAPPED_SUFFIX)) {
          return unwrapId(importee, WRAPPED_SUFFIX);
        }

        if (
          importee.endsWith(ENTRY_SUFFIX) ||
          isWrappedId(importee, MODULE_SUFFIX) ||
          isWrappedId(importee, EXPORTS_SUFFIX) ||
          isWrappedId(importee, PROXY_SUFFIX) ||
          isWrappedId(importee, ES_IMPORT_SUFFIX) ||
          isWrappedId(importee, EXTERNAL_SUFFIX) ||
          importee.startsWith(HELPERS_ID) ||
          importee === DYNAMIC_MODULES_ID
        ) {
          return importee;
        }

        if (importer) {
          if (
            importer === DYNAMIC_MODULES_ID ||
            // Proxies are only importing resolved ids, no need to resolve again
            isWrappedId(importer, PROXY_SUFFIX) ||
            isWrappedId(importer, ES_IMPORT_SUFFIX) ||
            importer.endsWith(ENTRY_SUFFIX)
          ) {
            return importee;
          }
          if (isWrappedId(importer, EXTERNAL_SUFFIX)) {
            // We need to return null for unresolved imports so that the proper warning is shown
            if (
              !(await this.resolve(
                importee,
                importer,
                Object.assign({ skipSelf: true }, resolveOptions)
              ))
            ) {
              return null;
            }
            // For other external imports, we need to make sure they are handled as external
            return { id: importee, external: true };
          }
        }

        if (importee.startsWith('\0')) {
          return null;
        }

        // If this is an entry point or ESM import, we need to figure out if the importee is wrapped and
        // if that is the case, we need to add a proxy.
        const resolved =
          (await this.resolve(
            importee,
            importer,
            Object.assign({ skipSelf: true }, resolveOptions)
          )) || resolveExtensions(importee, importer, extensions);
        // Make sure that even if other plugins resolve again, we ignore our own proxies
        if (
          !resolved ||
          resolved.external ||
          resolved.id.endsWith(ENTRY_SUFFIX) ||
          isWrappedId(resolved.id, ES_IMPORT_SUFFIX) ||
          !isPossibleCjsId(resolved.id)
        ) {
          return resolved;
        }
        const moduleInfo = await this.load(resolved);
        const {
          meta: { commonjs: commonjsMeta }
        } = moduleInfo;
        if (commonjsMeta) {
          const { isCommonJS } = commonjsMeta;
          if (isCommonJS) {
            if (resolveOptions.isEntry) {
              moduleInfo.moduleSideEffects = true;
              // We must not precede entry proxies with a `\0` as that will mess up relative external resolution
              return resolved.id + ENTRY_SUFFIX;
            }
            if (isCommonJS === IS_WRAPPED_COMMONJS) {
              return { id: wrapId(resolved.id, ES_IMPORT_SUFFIX), meta: { commonjs: { resolved } } };
            }
          }
        }
        return resolved;
      }
    };
  }

  function getRequireResolver(extensions, detectCyclesAndConditional, currentlyResolving) {
    const knownCjsModuleTypes = Object.create(null);
    const requiredIds = Object.create(null);
    const unconditionallyRequiredIds = Object.create(null);
    const dependencies = Object.create(null);
    const getDependencies = (id) => dependencies[id] || (dependencies[id] = new Set());

    const isCyclic = (id) => {
      const dependenciesToCheck = new Set(getDependencies(id));
      for (const dependency of dependenciesToCheck) {
        if (dependency === id) {
          return true;
        }
        for (const childDependency of getDependencies(dependency)) {
          dependenciesToCheck.add(childDependency);
        }
      }
      return false;
    };

    // Once a module is listed here, its type (wrapped or not) is fixed and may
    // not change for the rest of the current build, to not break already
    // transformed modules.
    const fullyAnalyzedModules = Object.create(null);

    const getTypeForFullyAnalyzedModule = (id) => {
      const knownType = knownCjsModuleTypes[id];
      if (knownType !== true || !detectCyclesAndConditional || fullyAnalyzedModules[id]) {
        return knownType;
      }
      if (isCyclic(id)) {
        return (knownCjsModuleTypes[id] = IS_WRAPPED_COMMONJS);
      }
      return knownType;
    };

    const setInitialParentType = (id, initialCommonJSType) => {
      // Fully analyzed modules may never change type
      if (fullyAnalyzedModules[id]) {
        return;
      }
      knownCjsModuleTypes[id] = initialCommonJSType;
      if (
        detectCyclesAndConditional &&
        knownCjsModuleTypes[id] === true &&
        requiredIds[id] &&
        !unconditionallyRequiredIds[id]
      ) {
        knownCjsModuleTypes[id] = IS_WRAPPED_COMMONJS;
      }
    };

    const analyzeRequiredModule = async (parentId, resolved, isConditional, loadModule) => {
      const childId = resolved.id;
      requiredIds[childId] = true;
      if (!(isConditional || knownCjsModuleTypes[parentId] === IS_WRAPPED_COMMONJS)) {
        unconditionallyRequiredIds[childId] = true;
      }

      getDependencies(parentId).add(childId);
      if (!isCyclic(childId)) {
        // This makes sure the current transform handler waits for all direct
        // dependencies to be loaded and transformed and therefore for all
        // transitive CommonJS dependencies to be loaded as well so that all
        // cycles have been found and knownCjsModuleTypes is reliable.
        await loadModule(resolved);
      }
    };

    const getTypeForImportedModule = async (resolved, loadModule) => {
      if (resolved.id in knownCjsModuleTypes) {
        // This handles cyclic ES dependencies
        return knownCjsModuleTypes[resolved.id];
      }
      const {
        meta: { commonjs }
      } = await loadModule(resolved);
      return (commonjs && commonjs.isCommonJS) || false;
    };

    return {
      getWrappedIds: () =>
        Object.keys(knownCjsModuleTypes).filter(
          (id) => knownCjsModuleTypes[id] === IS_WRAPPED_COMMONJS
        ),
      isRequiredId: (id) => requiredIds[id],
      async shouldTransformCachedModule({
        id: parentId,
        resolvedSources,
        meta: { commonjs: parentMeta }
      }) {
        // We explicitly track ES modules to handle circular imports
        if (!(parentMeta && parentMeta.isCommonJS)) knownCjsModuleTypes[parentId] = false;
        if (isWrappedId(parentId, ES_IMPORT_SUFFIX)) return false;
        const parentRequires = parentMeta && parentMeta.requires;
        if (parentRequires) {
          setInitialParentType(parentId, parentMeta.initialCommonJSType);
          await Promise.all(
            parentRequires.map(({ resolved, isConditional }) =>
              analyzeRequiredModule(parentId, resolved, isConditional, this.load)
            )
          );
          if (getTypeForFullyAnalyzedModule(parentId) !== parentMeta.isCommonJS) {
            return true;
          }
          for (const {
            resolved: { id }
          } of parentRequires) {
            if (getTypeForFullyAnalyzedModule(id) !== parentMeta.isRequiredCommonJS[id]) {
              return true;
            }
          }
          // Now that we decided to go with the cached copy, neither the parent
          // module nor any of its children may change types anymore
          fullyAnalyzedModules[parentId] = true;
          for (const {
            resolved: { id }
          } of parentRequires) {
            fullyAnalyzedModules[id] = true;
          }
        }
        const parentRequireSet = new Set((parentRequires || []).map(({ resolved: { id } }) => id));
        return (
          await Promise.all(
            Object.keys(resolvedSources)
              .map((source) => resolvedSources[source])
              .filter(({ id, external }) => !(external || parentRequireSet.has(id)))
              .map(async (resolved) => {
                if (isWrappedId(resolved.id, ES_IMPORT_SUFFIX)) {
                  return (
                    (await getTypeForImportedModule(
                      (
                        await this.load({ id: resolved.id })
                      ).meta.commonjs.resolved,
                      this.load
                    )) !== IS_WRAPPED_COMMONJS
                  );
                }
                return (await getTypeForImportedModule(resolved, this.load)) === IS_WRAPPED_COMMONJS;
              })
          )
        ).some((shouldTransform) => shouldTransform);
      },
      /* eslint-disable no-param-reassign */
      resolveRequireSourcesAndUpdateMeta:
        (rollupContext) => async (parentId, isParentCommonJS, parentMeta, sources) => {
          parentMeta.initialCommonJSType = isParentCommonJS;
          parentMeta.requires = [];
          parentMeta.isRequiredCommonJS = Object.create(null);
          setInitialParentType(parentId, isParentCommonJS);
          const currentlyResolvingForParent = currentlyResolving.get(parentId) || new Set();
          currentlyResolving.set(parentId, currentlyResolvingForParent);
          const requireTargets = await Promise.all(
            sources.map(async ({ source, isConditional }) => {
              // Never analyze or proxy internal modules
              if (source.startsWith('\0')) {
                return { id: source, allowProxy: false };
              }
              currentlyResolvingForParent.add(source);
              const resolved =
                (await rollupContext.resolve(source, parentId, {
                  skipSelf: false,
                  custom: { 'node-resolve': { isRequire: true } }
                })) || resolveExtensions(source, parentId, extensions);
              currentlyResolvingForParent.delete(source);
              if (!resolved) {
                return { id: wrapId(source, EXTERNAL_SUFFIX), allowProxy: false };
              }
              const childId = resolved.id;
              if (resolved.external) {
                return { id: wrapId(childId, EXTERNAL_SUFFIX), allowProxy: false };
              }
              parentMeta.requires.push({ resolved, isConditional });
              await analyzeRequiredModule(parentId, resolved, isConditional, rollupContext.load);
              return { id: childId, allowProxy: true };
            })
          );
          parentMeta.isCommonJS = getTypeForFullyAnalyzedModule(parentId);
          fullyAnalyzedModules[parentId] = true;
          return requireTargets.map(({ id: dependencyId, allowProxy }, index) => {
            // eslint-disable-next-line no-multi-assign
            const isCommonJS = (parentMeta.isRequiredCommonJS[dependencyId] =
              getTypeForFullyAnalyzedModule(dependencyId));
            const isWrappedCommonJS = isCommonJS === IS_WRAPPED_COMMONJS;
            fullyAnalyzedModules[dependencyId] = true;
            return {
              wrappedModuleSideEffects:
                isWrappedCommonJS && rollupContext.getModuleInfo(dependencyId).moduleSideEffects,
              source: sources[index].source,
              id: allowProxy
                ? wrapId(dependencyId, isWrappedCommonJS ? WRAPPED_SUFFIX : PROXY_SUFFIX)
                : dependencyId,
              isCommonJS
            };
          });
        },
      isCurrentlyResolving(source, parentId) {
        const currentlyResolvingForParent = currentlyResolving.get(parentId);
        return currentlyResolvingForParent && currentlyResolvingForParent.has(source);
      }
    };
  }

  function validateVersion(actualVersion, peerDependencyVersion, name) {
    const versionRegexp = /\^(\d+\.\d+\.\d+)/g;
    let minMajor = Infinity;
    let minMinor = Infinity;
    let minPatch = Infinity;
    let foundVersion;
    // eslint-disable-next-line no-cond-assign
    while ((foundVersion = versionRegexp.exec(peerDependencyVersion))) {
      const [foundMajor, foundMinor, foundPatch] = foundVersion[1].split('.').map(Number);
      if (foundMajor < minMajor) {
        minMajor = foundMajor;
        minMinor = foundMinor;
        minPatch = foundPatch;
      }
    }
    if (!actualVersion) {
      throw new Error(
        `Insufficient ${name} version: "@rollup/plugin-commonjs" requires at least ${name}@${minMajor}.${minMinor}.${minPatch}.`
      );
    }
    const [major, minor, patch] = actualVersion.split('.').map(Number);
    if (
      major < minMajor ||
      (major === minMajor && (minor < minMinor || (minor === minMinor && patch < minPatch)))
    ) {
      throw new Error(
        `Insufficient ${name} version: "@rollup/plugin-commonjs" requires at least ${name}@${minMajor}.${minMinor}.${minPatch} but found ${name}@${actualVersion}.`
      );
    }
  }

  const operators = {
    '==': (x) => equals(x.left, x.right, false),

    '!=': (x) => not(operators['=='](x)),

    '===': (x) => equals(x.left, x.right, true),

    '!==': (x) => not(operators['==='](x)),

    '!': (x) => isFalsy(x.argument),

    '&&': (x) => isTruthy(x.left) && isTruthy(x.right),

    '||': (x) => isTruthy(x.left) || isTruthy(x.right)
  };

  function not(value) {
    return value === null ? value : !value;
  }

  function equals(a, b, strict) {
    if (a.type !== b.type) return null;
    // eslint-disable-next-line eqeqeq
    if (a.type === 'Literal') return strict ? a.value === b.value : a.value == b.value;
    return null;
  }

  function isTruthy(node) {
    if (!node) return false;
    if (node.type === 'Literal') return !!node.value;
    if (node.type === 'ParenthesizedExpression') return isTruthy(node.expression);
    if (node.operator in operators) return operators[node.operator](node);
    return null;
  }

  function isFalsy(node) {
    return not(isTruthy(node));
  }

  function getKeypath(node) {
    const parts = [];

    while (node.type === 'MemberExpression') {
      if (node.computed) return null;

      parts.unshift(node.property.name);
      // eslint-disable-next-line no-param-reassign
      node = node.object;
    }

    if (node.type !== 'Identifier') return null;

    const { name } = node;
    parts.unshift(name);

    return { name, keypath: parts.join('.') };
  }

  const KEY_COMPILED_ESM = '__esModule';

  function getDefineCompiledEsmType(node) {
    const definedPropertyWithExports = getDefinePropertyCallName(node, 'exports');
    const definedProperty =
      definedPropertyWithExports || getDefinePropertyCallName(node, 'module.exports');
    if (definedProperty && definedProperty.key === KEY_COMPILED_ESM) {
      return isTruthy(definedProperty.value)
        ? definedPropertyWithExports
          ? 'exports'
          : 'module'
        : false;
    }
    return false;
  }

  function getDefinePropertyCallName(node, targetName) {
    const {
      callee: { object, property }
    } = node;
    if (!object || object.type !== 'Identifier' || object.name !== 'Object') return;
    if (!property || property.type !== 'Identifier' || property.name !== 'defineProperty') return;
    if (node.arguments.length !== 3) return;

    const targetNames = targetName.split('.');
    const [target, key, value] = node.arguments;
    if (targetNames.length === 1) {
      if (target.type !== 'Identifier' || target.name !== targetNames[0]) {
        return;
      }
    }

    if (targetNames.length === 2) {
      if (
        target.type !== 'MemberExpression' ||
        target.object.name !== targetNames[0] ||
        target.property.name !== targetNames[1]
      ) {
        return;
      }
    }

    if (value.type !== 'ObjectExpression' || !value.properties) return;

    const valueProperty = value.properties.find((p) => p.key && p.key.name === 'value');
    if (!valueProperty || !valueProperty.value) return;

    // eslint-disable-next-line consistent-return
    return { key: key.value, value: valueProperty.value };
  }

  function isShorthandProperty(parent) {
    return parent && parent.type === 'Property' && parent.shorthand;
  }

  function wrapCode(magicString, uses, moduleName, exportsName, indentExclusionRanges) {
    const args = [];
    const passedArgs = [];
    if (uses.module) {
      args.push('module');
      passedArgs.push(moduleName);
    }
    if (uses.exports) {
      args.push('exports');
      passedArgs.push(uses.module ? `${moduleName}.exports` : exportsName);
    }
    magicString
      .trim()
      .indent('\t', { exclude: indentExclusionRanges })
      .prepend(`(function (${args.join(', ')}) {\n`)
      // For some reason, this line is only indented correctly when using a
      // require-wrapper if we have this leading space
      .append(` \n} (${passedArgs.join(', ')}));`);
  }

  function rewriteExportsAndGetExportsBlock(
    magicString,
    moduleName,
    exportsName,
    exportedExportsName,
    wrapped,
    moduleExportsAssignments,
    firstTopLevelModuleExportsAssignment,
    exportsAssignmentsByName,
    topLevelAssignments,
    defineCompiledEsmExpressions,
    deconflictedExportNames,
    code,
    HELPERS_NAME,
    exportMode,
    defaultIsModuleExports,
    usesRequireWrapper,
    requireName
  ) {
    const exports = [];
    const exportDeclarations = [];

    if (usesRequireWrapper) {
      getExportsWhenUsingRequireWrapper(
        magicString,
        wrapped,
        exportMode,
        exports,
        moduleExportsAssignments,
        exportsAssignmentsByName,
        moduleName,
        exportsName,
        requireName,
        defineCompiledEsmExpressions
      );
    } else if (exportMode === 'replace') {
      getExportsForReplacedModuleExports(
        magicString,
        exports,
        exportDeclarations,
        moduleExportsAssignments,
        firstTopLevelModuleExportsAssignment,
        exportsName,
        defaultIsModuleExports,
        HELPERS_NAME
      );
    } else {
      if (exportMode === 'module') {
        exportDeclarations.push(`var ${exportedExportsName} = ${moduleName}.exports`);
        exports.push(`${exportedExportsName} as __moduleExports`);
      } else {
        exports.push(`${exportsName} as __moduleExports`);
      }
      if (wrapped) {
        exportDeclarations.push(
          getDefaultExportDeclaration(exportedExportsName, defaultIsModuleExports, HELPERS_NAME)
        );
      } else {
        getExports(
          magicString,
          exports,
          exportDeclarations,
          moduleExportsAssignments,
          exportsAssignmentsByName,
          deconflictedExportNames,
          topLevelAssignments,
          moduleName,
          exportsName,
          exportedExportsName,
          defineCompiledEsmExpressions,
          HELPERS_NAME,
          defaultIsModuleExports,
          exportMode
        );
      }
    }
    if (exports.length) {
      exportDeclarations.push(`export { ${exports.join(', ')} }`);
    }

    return `\n\n${exportDeclarations.join(';\n')};`;
  }

  function getExportsWhenUsingRequireWrapper(
    magicString,
    wrapped,
    exportMode,
    exports,
    moduleExportsAssignments,
    exportsAssignmentsByName,
    moduleName,
    exportsName,
    requireName,
    defineCompiledEsmExpressions
  ) {
    exports.push(`${requireName} as __require`);
    if (wrapped) return;
    if (exportMode === 'replace') {
      rewriteModuleExportsAssignments(magicString, moduleExportsAssignments, exportsName);
    } else {
      rewriteModuleExportsAssignments(magicString, moduleExportsAssignments, `${moduleName}.exports`);
      // Collect and rewrite named exports
      for (const [exportName, { nodes }] of exportsAssignmentsByName) {
        for (const { node, type } of nodes) {
          magicString.overwrite(
            node.start,
            node.left.end,
            `${
            exportMode === 'module' && type === 'module' ? `${moduleName}.exports` : exportsName
          }.${exportName}`
          );
        }
      }
      replaceDefineCompiledEsmExpressionsAndGetIfRestorable(
        defineCompiledEsmExpressions,
        magicString,
        exportMode,
        moduleName,
        exportsName
      );
    }
  }

  function getExportsForReplacedModuleExports(
    magicString,
    exports,
    exportDeclarations,
    moduleExportsAssignments,
    firstTopLevelModuleExportsAssignment,
    exportsName,
    defaultIsModuleExports,
    HELPERS_NAME
  ) {
    for (const { left } of moduleExportsAssignments) {
      magicString.overwrite(left.start, left.end, exportsName);
    }
    magicString.prependRight(firstTopLevelModuleExportsAssignment.left.start, 'var ');
    exports.push(`${exportsName} as __moduleExports`);
    exportDeclarations.push(
      getDefaultExportDeclaration(exportsName, defaultIsModuleExports, HELPERS_NAME)
    );
  }

  function getDefaultExportDeclaration(exportedExportsName, defaultIsModuleExports, HELPERS_NAME) {
    return `export default ${
    defaultIsModuleExports === true
      ? exportedExportsName
      : defaultIsModuleExports === false
      ? `${exportedExportsName}.default`
      : `/*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportedExportsName})`
  }`;
  }

  function getExports(
    magicString,
    exports,
    exportDeclarations,
    moduleExportsAssignments,
    exportsAssignmentsByName,
    deconflictedExportNames,
    topLevelAssignments,
    moduleName,
    exportsName,
    exportedExportsName,
    defineCompiledEsmExpressions,
    HELPERS_NAME,
    defaultIsModuleExports,
    exportMode
  ) {
    let deconflictedDefaultExportName;
    // Collect and rewrite module.exports assignments
    for (const { left } of moduleExportsAssignments) {
      magicString.overwrite(left.start, left.end, `${moduleName}.exports`);
    }

    // Collect and rewrite named exports
    for (const [exportName, { nodes }] of exportsAssignmentsByName) {
      const deconflicted = deconflictedExportNames[exportName];
      let needsDeclaration = true;
      for (const { node, type } of nodes) {
        let replacement = `${deconflicted} = ${
        exportMode === 'module' && type === 'module' ? `${moduleName}.exports` : exportsName
      }.${exportName}`;
        if (needsDeclaration && topLevelAssignments.has(node)) {
          replacement = `var ${replacement}`;
          needsDeclaration = false;
        }
        magicString.overwrite(node.start, node.left.end, replacement);
      }
      if (needsDeclaration) {
        magicString.prepend(`var ${deconflicted};\n`);
      }

      if (exportName === 'default') {
        deconflictedDefaultExportName = deconflicted;
      } else {
        exports.push(exportName === deconflicted ? exportName : `${deconflicted} as ${exportName}`);
      }
    }

    const isRestorableCompiledEsm = replaceDefineCompiledEsmExpressionsAndGetIfRestorable(
      defineCompiledEsmExpressions,
      magicString,
      exportMode,
      moduleName,
      exportsName
    );

    if (
      defaultIsModuleExports === false ||
      (defaultIsModuleExports === 'auto' &&
        isRestorableCompiledEsm &&
        moduleExportsAssignments.length === 0)
    ) {
      // If there is no deconflictedDefaultExportName, then we use the namespace as
      // fallback because there can be no "default" property on the namespace
      exports.push(`${deconflictedDefaultExportName || exportedExportsName} as default`);
    } else if (
      defaultIsModuleExports === true ||
      (!isRestorableCompiledEsm && moduleExportsAssignments.length === 0)
    ) {
      exports.push(`${exportedExportsName} as default`);
    } else {
      exportDeclarations.push(
        getDefaultExportDeclaration(exportedExportsName, defaultIsModuleExports, HELPERS_NAME)
      );
    }
  }

  function rewriteModuleExportsAssignments(magicString, moduleExportsAssignments, exportsName) {
    for (const { left } of moduleExportsAssignments) {
      magicString.overwrite(left.start, left.end, exportsName);
    }
  }

  function replaceDefineCompiledEsmExpressionsAndGetIfRestorable(
    defineCompiledEsmExpressions,
    magicString,
    exportMode,
    moduleName,
    exportsName
  ) {
    let isRestorableCompiledEsm = false;
    for (const { node, type } of defineCompiledEsmExpressions) {
      isRestorableCompiledEsm = true;
      const moduleExportsExpression =
        node.type === 'CallExpression' ? node.arguments[0] : node.left.object;
      magicString.overwrite(
        moduleExportsExpression.start,
        moduleExportsExpression.end,
        exportMode === 'module' && type === 'module' ? `${moduleName}.exports` : exportsName
      );
    }
    return isRestorableCompiledEsm;
  }

  function isRequireExpression(node, scope) {
    if (!node) return false;
    if (node.type !== 'CallExpression') return false;

    // Weird case of `require()` or `module.require()` without arguments
    if (node.arguments.length === 0) return false;

    return isRequire(node.callee, scope);
  }

  function isRequire(node, scope) {
    return (
      (node.type === 'Identifier' && node.name === 'require' && !scope.contains('require')) ||
      (node.type === 'MemberExpression' && isModuleRequire(node, scope))
    );
  }

  function isModuleRequire({ object, property }, scope) {
    return (
      object.type === 'Identifier' &&
      object.name === 'module' &&
      property.type === 'Identifier' &&
      property.name === 'require' &&
      !scope.contains('module')
    );
  }

  function hasDynamicArguments(node) {
    return (
      node.arguments.length > 1 ||
      (node.arguments[0].type !== 'Literal' &&
        (node.arguments[0].type !== 'TemplateLiteral' || node.arguments[0].expressions.length > 0))
    );
  }

  const reservedMethod = { resolve: true, cache: true, main: true };

  function isNodeRequirePropertyAccess(parent) {
    return parent && parent.property && reservedMethod[parent.property.name];
  }

  function getRequireStringArg(node) {
    return node.arguments[0].type === 'Literal'
      ? node.arguments[0].value
      : node.arguments[0].quasis[0].value.cooked;
  }

  function getRequireHandlers() {
    const requireExpressions = [];

    function addRequireExpression(
      sourceId,
      node,
      scope,
      usesReturnValue,
      isInsideTryBlock,
      isInsideConditional,
      toBeRemoved
    ) {
      requireExpressions.push({
        sourceId,
        node,
        scope,
        usesReturnValue,
        isInsideTryBlock,
        isInsideConditional,
        toBeRemoved
      });
    }

    async function rewriteRequireExpressionsAndGetImportBlock(
      magicString,
      topLevelDeclarations,
      reassignedNames,
      helpersName,
      dynamicRequireName,
      moduleName,
      exportsName,
      id,
      exportMode,
      resolveRequireSourcesAndUpdateMeta,
      needsRequireWrapper,
      isEsModule,
      isDynamicRequireModulesEnabled,
      getIgnoreTryCatchRequireStatementMode,
      commonjsMeta
    ) {
      const imports = [];
      imports.push(`import * as ${helpersName} from "${HELPERS_ID}"`);
      if (dynamicRequireName) {
        imports.push(
          `import { ${
          isDynamicRequireModulesEnabled ? CREATE_COMMONJS_REQUIRE_EXPORT : COMMONJS_REQUIRE_EXPORT
        } as ${dynamicRequireName} } from "${DYNAMIC_MODULES_ID}"`
        );
      }
      if (exportMode === 'module') {
        imports.push(
          `import { __module as ${moduleName} } from ${JSON.stringify(wrapId(id, MODULE_SUFFIX))}`,
          `var ${exportsName} = ${moduleName}.exports`
        );
      } else if (exportMode === 'exports') {
        imports.push(
          `import { __exports as ${exportsName} } from ${JSON.stringify(wrapId(id, EXPORTS_SUFFIX))}`
        );
      }
      const requiresBySource = collectSources(requireExpressions);
      const requireTargets = await resolveRequireSourcesAndUpdateMeta(
        id,
        needsRequireWrapper ? IS_WRAPPED_COMMONJS : !isEsModule,
        commonjsMeta,
        Object.keys(requiresBySource).map((source) => {
          return {
            source,
            isConditional: requiresBySource[source].every((require) => require.isInsideConditional)
          };
        })
      );
      processRequireExpressions(
        imports,
        requireTargets,
        requiresBySource,
        getIgnoreTryCatchRequireStatementMode,
        magicString
      );
      return imports.length ? `${imports.join(';\n')};\n\n` : '';
    }

    return {
      addRequireExpression,
      rewriteRequireExpressionsAndGetImportBlock
    };
  }

  function collectSources(requireExpressions) {
    const requiresBySource = Object.create(null);
    for (const requireExpression of requireExpressions) {
      const { sourceId } = requireExpression;
      if (!requiresBySource[sourceId]) {
        requiresBySource[sourceId] = [];
      }
      const requires = requiresBySource[sourceId];
      requires.push(requireExpression);
    }
    return requiresBySource;
  }

  function processRequireExpressions(
    imports,
    requireTargets,
    requiresBySource,
    getIgnoreTryCatchRequireStatementMode,
    magicString
  ) {
    const generateRequireName = getGenerateRequireName();
    for (const { source, id: resolvedId, isCommonJS, wrappedModuleSideEffects } of requireTargets) {
      const requires = requiresBySource[source];
      const name = generateRequireName(requires);
      let usesRequired = false;
      let needsImport = false;
      for (const { node, usesReturnValue, toBeRemoved, isInsideTryBlock } of requires) {
        const { canConvertRequire, shouldRemoveRequire } =
          isInsideTryBlock && isWrappedId(resolvedId, EXTERNAL_SUFFIX)
            ? getIgnoreTryCatchRequireStatementMode(source)
            : { canConvertRequire: true, shouldRemoveRequire: false };
        if (shouldRemoveRequire) {
          if (usesReturnValue) {
            magicString.overwrite(node.start, node.end, 'undefined');
          } else {
            magicString.remove(toBeRemoved.start, toBeRemoved.end);
          }
        } else if (canConvertRequire) {
          needsImport = true;
          if (isCommonJS === IS_WRAPPED_COMMONJS) {
            magicString.overwrite(
              node.start,
              node.end,
              `${wrappedModuleSideEffects ? '' : '/*@__PURE__*/ '}${name}()`
            );
          } else if (usesReturnValue) {
            usesRequired = true;
            magicString.overwrite(node.start, node.end, name);
          } else {
            magicString.remove(toBeRemoved.start, toBeRemoved.end);
          }
        }
      }
      if (needsImport) {
        if (isCommonJS === IS_WRAPPED_COMMONJS) {
          imports.push(`import { __require as ${name} } from ${JSON.stringify(resolvedId)}`);
        } else {
          imports.push(`import ${usesRequired ? `${name} from ` : ''}${JSON.stringify(resolvedId)}`);
        }
      }
    }
  }

  function getGenerateRequireName() {
    let uid = 0;
    return (requires) => {
      let name;
      const hasNameConflict = ({ scope }) => scope.contains(name);
      do {
        name = `require$$${uid}`;
        uid += 1;
      } while (requires.some(hasNameConflict));
      return name;
    };
  }

  /* eslint-disable no-param-reassign, no-shadow, no-underscore-dangle, no-continue */


  const exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;

  const functionType = /^(?:FunctionDeclaration|FunctionExpression|ArrowFunctionExpression)$/;

  // There are three different types of CommonJS modules, described by their
  // "exportMode":
  // - exports: Only assignments to (module.)exports properties
  // - replace: A single assignment to module.exports itself
  // - module: Anything else
  // Special cases:
  // - usesRequireWrapper
  // - isWrapped
  async function transformCommonjs(
    parse,
    code,
    id,
    isEsModule,
    ignoreGlobal,
    ignoreRequire,
    ignoreDynamicRequires,
    getIgnoreTryCatchRequireStatementMode,
    sourceMap,
    isDynamicRequireModulesEnabled,
    dynamicRequireModules,
    commonDir,
    astCache,
    defaultIsModuleExports,
    needsRequireWrapper,
    resolveRequireSourcesAndUpdateMeta,
    isRequired,
    checkDynamicRequire,
    commonjsMeta
  ) {
    const ast = astCache || tryParse(parse, code, id);
    const magicString = new MagicString(code);
    const uses = {
      module: false,
      exports: false,
      global: false,
      require: false
    };
    const virtualDynamicRequirePath =
      isDynamicRequireModulesEnabled && getVirtualPathForDynamicRequirePath(require$$0.dirname(id), commonDir);
    let scope = attachScopes(ast, 'scope');
    let lexicalDepth = 0;
    let programDepth = 0;
    let classBodyDepth = 0;
    let currentTryBlockEnd = null;
    let shouldWrap = false;

    const globals = new Set();
    // A conditionalNode is a node for which execution is not guaranteed. If such a node is a require
    // or contains nested requires, those should be handled as function calls unless there is an
    // unconditional require elsewhere.
    let currentConditionalNodeEnd = null;
    const conditionalNodes = new Set();
    const { addRequireExpression, rewriteRequireExpressionsAndGetImportBlock } = getRequireHandlers();

    // See which names are assigned to. This is necessary to prevent
    // illegally replacing `var foo = require('foo')` with `import foo from 'foo'`,
    // where `foo` is later reassigned. (This happens in the wild. CommonJS, sigh)
    const reassignedNames = new Set();
    const topLevelDeclarations = [];
    const skippedNodes = new Set();
    const moduleAccessScopes = new Set([scope]);
    const exportsAccessScopes = new Set([scope]);
    const moduleExportsAssignments = [];
    let firstTopLevelModuleExportsAssignment = null;
    const exportsAssignmentsByName = new Map();
    const topLevelAssignments = new Set();
    const topLevelDefineCompiledEsmExpressions = [];
    const replacedGlobal = [];
    const replacedThis = [];
    const replacedDynamicRequires = [];
    const importedVariables = new Set();
    const indentExclusionRanges = [];

    walk(ast, {
      enter(node, parent) {
        if (skippedNodes.has(node)) {
          this.skip();
          return;
        }

        if (currentTryBlockEnd !== null && node.start > currentTryBlockEnd) {
          currentTryBlockEnd = null;
        }
        if (currentConditionalNodeEnd !== null && node.start > currentConditionalNodeEnd) {
          currentConditionalNodeEnd = null;
        }
        if (currentConditionalNodeEnd === null && conditionalNodes.has(node)) {
          currentConditionalNodeEnd = node.end;
        }

        programDepth += 1;
        if (node.scope) ({ scope } = node);
        if (functionType.test(node.type)) lexicalDepth += 1;
        if (sourceMap) {
          magicString.addSourcemapLocation(node.start);
          magicString.addSourcemapLocation(node.end);
        }

        // eslint-disable-next-line default-case
        switch (node.type) {
          case 'AssignmentExpression':
            if (node.left.type === 'MemberExpression') {
              const flattened = getKeypath(node.left);
              if (!flattened || scope.contains(flattened.name)) return;

              const exportsPatternMatch = exportsPattern.exec(flattened.keypath);
              if (!exportsPatternMatch || flattened.keypath === 'exports') return;

              const [, exportName] = exportsPatternMatch;
              uses[flattened.name] = true;

              // we're dealing with `module.exports = ...` or `[module.]exports.foo = ...` –
              if (flattened.keypath === 'module.exports') {
                moduleExportsAssignments.push(node);
                if (programDepth > 3) {
                  moduleAccessScopes.add(scope);
                } else if (!firstTopLevelModuleExportsAssignment) {
                  firstTopLevelModuleExportsAssignment = node;
                }
              } else if (exportName === KEY_COMPILED_ESM) {
                if (programDepth > 3) {
                  shouldWrap = true;
                } else {
                  // The "type" is either "module" or "exports" to discern
                  // assignments to module.exports vs exports if needed
                  topLevelDefineCompiledEsmExpressions.push({ node, type: flattened.name });
                }
              } else {
                const exportsAssignments = exportsAssignmentsByName.get(exportName) || {
                  nodes: [],
                  scopes: new Set()
                };
                exportsAssignments.nodes.push({ node, type: flattened.name });
                exportsAssignments.scopes.add(scope);
                exportsAccessScopes.add(scope);
                exportsAssignmentsByName.set(exportName, exportsAssignments);
                if (programDepth <= 3) {
                  topLevelAssignments.add(node);
                }
              }

              skippedNodes.add(node.left);
            } else {
              for (const name of extractAssignedNames(node.left)) {
                reassignedNames.add(name);
              }
            }
            return;
          case 'CallExpression': {
            const defineCompiledEsmType = getDefineCompiledEsmType(node);
            if (defineCompiledEsmType) {
              if (programDepth === 3 && parent.type === 'ExpressionStatement') {
                // skip special handling for [module.]exports until we know we render this
                skippedNodes.add(node.arguments[0]);
                topLevelDefineCompiledEsmExpressions.push({ node, type: defineCompiledEsmType });
              } else {
                shouldWrap = true;
              }
              return;
            }

            // Transform require.resolve
            if (
              isDynamicRequireModulesEnabled &&
              node.callee.object &&
              isRequire(node.callee.object, scope) &&
              node.callee.property.name === 'resolve'
            ) {
              checkDynamicRequire(node.start);
              uses.require = true;
              const requireNode = node.callee.object;
              replacedDynamicRequires.push(requireNode);
              skippedNodes.add(node.callee);
              return;
            }

            if (!isRequireExpression(node, scope)) {
              const keypath = getKeypath(node.callee);
              if (keypath && importedVariables.has(keypath.name)) {
                // Heuristic to deoptimize requires after a required function has been called
                currentConditionalNodeEnd = Infinity;
              }
              return;
            }

            skippedNodes.add(node.callee);
            uses.require = true;

            if (hasDynamicArguments(node)) {
              if (isDynamicRequireModulesEnabled) {
                checkDynamicRequire(node.start);
              }
              if (!ignoreDynamicRequires) {
                replacedDynamicRequires.push(node.callee);
              }
              return;
            }

            const requireStringArg = getRequireStringArg(node);
            if (!ignoreRequire(requireStringArg)) {
              const usesReturnValue = parent.type !== 'ExpressionStatement';
              const toBeRemoved =
                parent.type === 'ExpressionStatement' &&
                (!currentConditionalNodeEnd ||
                  // We should completely remove requires directly in a try-catch
                  // so that Rollup can remove up the try-catch
                  (currentTryBlockEnd !== null && currentTryBlockEnd < currentConditionalNodeEnd))
                  ? parent
                  : node;
              addRequireExpression(
                requireStringArg,
                node,
                scope,
                usesReturnValue,
                currentTryBlockEnd !== null,
                currentConditionalNodeEnd !== null,
                toBeRemoved
              );
              if (parent.type === 'VariableDeclarator' && parent.id.type === 'Identifier') {
                for (const name of extractAssignedNames(parent.id)) {
                  importedVariables.add(name);
                }
              }
            }
            return;
          }
          case 'ClassBody':
            classBodyDepth += 1;
            return;
          case 'ConditionalExpression':
          case 'IfStatement':
            // skip dead branches
            if (isFalsy(node.test)) {
              skippedNodes.add(node.consequent);
            } else if (isTruthy(node.test)) {
              if (node.alternate) {
                skippedNodes.add(node.alternate);
              }
            } else {
              conditionalNodes.add(node.consequent);
              if (node.alternate) {
                conditionalNodes.add(node.alternate);
              }
            }
            return;
          case 'ArrowFunctionExpression':
          case 'FunctionDeclaration':
          case 'FunctionExpression':
            // requires in functions should be conditional unless it is an IIFE
            if (
              currentConditionalNodeEnd === null &&
              !(parent.type === 'CallExpression' && parent.callee === node)
            ) {
              currentConditionalNodeEnd = node.end;
            }
            return;
          case 'Identifier': {
            const { name } = node;
            if (
              !isReference(node, parent) ||
              scope.contains(name) ||
              (parent.type === 'PropertyDefinition' && parent.key === node)
            )
              return;
            switch (name) {
              case 'require':
                uses.require = true;
                if (isNodeRequirePropertyAccess(parent)) {
                  return;
                }
                if (!ignoreDynamicRequires) {
                  if (isShorthandProperty(parent)) {
                    // as key and value are the same object, isReference regards
                    // both as references, so we need to skip now
                    skippedNodes.add(parent.value);
                    magicString.prependRight(node.start, 'require: ');
                  }
                  replacedDynamicRequires.push(node);
                }
                return;
              case 'module':
              case 'exports':
                shouldWrap = true;
                uses[name] = true;
                return;
              case 'global':
                uses.global = true;
                if (!ignoreGlobal) {
                  replacedGlobal.push(node);
                }
                return;
              case 'define':
                magicString.overwrite(node.start, node.end, 'undefined', {
                  storeName: true
                });
                return;
              default:
                globals.add(name);
                return;
            }
          }
          case 'LogicalExpression':
            // skip dead branches
            if (node.operator === '&&') {
              if (isFalsy(node.left)) {
                skippedNodes.add(node.right);
              } else if (!isTruthy(node.left)) {
                conditionalNodes.add(node.right);
              }
            } else if (node.operator === '||') {
              if (isTruthy(node.left)) {
                skippedNodes.add(node.right);
              } else if (!isFalsy(node.left)) {
                conditionalNodes.add(node.right);
              }
            }
            return;
          case 'MemberExpression':
            if (!isDynamicRequireModulesEnabled && isModuleRequire(node, scope)) {
              uses.require = true;
              replacedDynamicRequires.push(node);
              skippedNodes.add(node.object);
              skippedNodes.add(node.property);
            }
            return;
          case 'ReturnStatement':
            // if top-level return, we need to wrap it
            if (lexicalDepth === 0) {
              shouldWrap = true;
            }
            return;
          case 'ThisExpression':
            // rewrite top-level `this` as `commonjsHelpers.commonjsGlobal`
            if (lexicalDepth === 0 && !classBodyDepth) {
              uses.global = true;
              if (!ignoreGlobal) {
                replacedThis.push(node);
              }
            }
            return;
          case 'TryStatement':
            if (currentTryBlockEnd === null) {
              currentTryBlockEnd = node.block.end;
            }
            if (currentConditionalNodeEnd === null) {
              currentConditionalNodeEnd = node.end;
            }
            return;
          case 'UnaryExpression':
            // rewrite `typeof module`, `typeof module.exports` and `typeof exports` (https://github.com/rollup/rollup-plugin-commonjs/issues/151)
            if (node.operator === 'typeof') {
              const flattened = getKeypath(node.argument);
              if (!flattened) return;

              if (scope.contains(flattened.name)) return;

              if (
                !isEsModule &&
                (flattened.keypath === 'module.exports' ||
                  flattened.keypath === 'module' ||
                  flattened.keypath === 'exports')
              ) {
                magicString.overwrite(node.start, node.end, `'object'`, {
                  storeName: false
                });
              }
            }
            return;
          case 'VariableDeclaration':
            if (!scope.parent) {
              topLevelDeclarations.push(node);
            }
            return;
          case 'TemplateElement':
            if (node.value.raw.includes('\n')) {
              indentExclusionRanges.push([node.start, node.end]);
            }
        }
      },

      leave(node) {
        programDepth -= 1;
        if (node.scope) scope = scope.parent;
        if (functionType.test(node.type)) lexicalDepth -= 1;
        if (node.type === 'ClassBody') classBodyDepth -= 1;
      }
    });

    const nameBase = getName(id);
    const exportsName = deconflict([...exportsAccessScopes], globals, nameBase);
    const moduleName = deconflict([...moduleAccessScopes], globals, `${nameBase}Module`);
    const requireName = deconflict([scope], globals, `require${capitalize(nameBase)}`);
    const isRequiredName = deconflict([scope], globals, `hasRequired${capitalize(nameBase)}`);
    const helpersName = deconflict([scope], globals, 'commonjsHelpers');
    const dynamicRequireName =
      replacedDynamicRequires.length > 0 &&
      deconflict(
        [scope],
        globals,
        isDynamicRequireModulesEnabled ? CREATE_COMMONJS_REQUIRE_EXPORT : COMMONJS_REQUIRE_EXPORT
      );
    const deconflictedExportNames = Object.create(null);
    for (const [exportName, { scopes }] of exportsAssignmentsByName) {
      deconflictedExportNames[exportName] = deconflict([...scopes], globals, exportName);
    }

    for (const node of replacedGlobal) {
      magicString.overwrite(node.start, node.end, `${helpersName}.commonjsGlobal`, {
        storeName: true
      });
    }
    for (const node of replacedThis) {
      magicString.overwrite(node.start, node.end, exportsName, {
        storeName: true
      });
    }
    for (const node of replacedDynamicRequires) {
      magicString.overwrite(
        node.start,
        node.end,
        isDynamicRequireModulesEnabled
          ? `${dynamicRequireName}(${JSON.stringify(virtualDynamicRequirePath)})`
          : dynamicRequireName,
        {
          contentOnly: true,
          storeName: true
        }
      );
    }

    // We cannot wrap ES/mixed modules
    shouldWrap = !isEsModule && (shouldWrap || (uses.exports && moduleExportsAssignments.length > 0));

    if (
      !(
        shouldWrap ||
        isRequired ||
        needsRequireWrapper ||
        uses.module ||
        uses.exports ||
        uses.require ||
        topLevelDefineCompiledEsmExpressions.length > 0
      ) &&
      (ignoreGlobal || !uses.global)
    ) {
      return { meta: { commonjs: { isCommonJS: false } } };
    }

    let leadingComment = '';
    if (code.startsWith('/*')) {
      const commentEnd = code.indexOf('*/', 2) + 2;
      leadingComment = `${code.slice(0, commentEnd)}\n`;
      magicString.remove(0, commentEnd).trim();
    }

    let shebang = '';
    if (code.startsWith('#!')) {
      const shebangEndPosition = code.indexOf('\n') + 1;
      shebang = code.slice(0, shebangEndPosition);
      magicString.remove(0, shebangEndPosition).trim();
    }

    const exportMode = isEsModule
      ? 'none'
      : shouldWrap
      ? uses.module
        ? 'module'
        : 'exports'
      : firstTopLevelModuleExportsAssignment
      ? exportsAssignmentsByName.size === 0 && topLevelDefineCompiledEsmExpressions.length === 0
        ? 'replace'
        : 'module'
      : moduleExportsAssignments.length === 0
      ? 'exports'
      : 'module';

    const exportedExportsName =
      exportMode === 'module' ? deconflict([], globals, `${nameBase}Exports`) : exportsName;

    const importBlock = await rewriteRequireExpressionsAndGetImportBlock(
      magicString,
      topLevelDeclarations,
      reassignedNames,
      helpersName,
      dynamicRequireName,
      moduleName,
      exportsName,
      id,
      exportMode,
      resolveRequireSourcesAndUpdateMeta,
      needsRequireWrapper,
      isEsModule,
      isDynamicRequireModulesEnabled,
      getIgnoreTryCatchRequireStatementMode,
      commonjsMeta
    );
    const usesRequireWrapper = commonjsMeta.isCommonJS === IS_WRAPPED_COMMONJS;
    const exportBlock = isEsModule
      ? ''
      : rewriteExportsAndGetExportsBlock(
          magicString,
          moduleName,
          exportsName,
          exportedExportsName,
          shouldWrap,
          moduleExportsAssignments,
          firstTopLevelModuleExportsAssignment,
          exportsAssignmentsByName,
          topLevelAssignments,
          topLevelDefineCompiledEsmExpressions,
          deconflictedExportNames,
          code,
          helpersName,
          exportMode,
          defaultIsModuleExports,
          usesRequireWrapper,
          requireName
        );

    if (shouldWrap) {
      wrapCode(magicString, uses, moduleName, exportsName, indentExclusionRanges);
    }

    if (usesRequireWrapper) {
      magicString.trim().indent('\t', {
        exclude: indentExclusionRanges
      });
      const exported = exportMode === 'module' ? `${moduleName}.exports` : exportsName;
      magicString.prepend(
        `var ${isRequiredName};

function ${requireName} () {
\tif (${isRequiredName}) return ${exported};
\t${isRequiredName} = 1;
`
      ).append(`
\treturn ${exported};
}`);
      if (exportMode === 'replace') {
        magicString.prepend(`var ${exportsName};\n`);
      }
    }

    magicString
      .trim()
      .prepend(shebang + leadingComment + importBlock)
      .append(exportBlock);

    return {
      code: magicString.toString(),
      map: sourceMap ? magicString.generateMap() : null,
      syntheticNamedExports: isEsModule || usesRequireWrapper ? false : '__moduleExports',
      meta: { commonjs: { ...commonjsMeta, shebang } }
    };
  }

  const PLUGIN_NAME = 'commonjs';

  function commonjs(options = {}) {
    const {
      ignoreGlobal,
      ignoreDynamicRequires,
      requireReturnsDefault: requireReturnsDefaultOption,
      defaultIsModuleExports: defaultIsModuleExportsOption,
      esmExternals
    } = options;
    const extensions = options.extensions || ['.js'];
    const filter = createFilter(options.include, options.exclude);
    const isPossibleCjsId = (id) => {
      const extName = require$$0.extname(id);
      return extName === '.cjs' || (extensions.includes(extName) && filter(id));
    };

    const { strictRequiresFilter, detectCyclesAndConditional } = getStrictRequiresFilter(options);

    const getRequireReturnsDefault =
      typeof requireReturnsDefaultOption === 'function'
        ? requireReturnsDefaultOption
        : () => requireReturnsDefaultOption;

    let esmExternalIds;
    const isEsmExternal =
      typeof esmExternals === 'function'
        ? esmExternals
        : Array.isArray(esmExternals)
        ? ((esmExternalIds = new Set(esmExternals)), (id) => esmExternalIds.has(id))
        : () => esmExternals;

    const getDefaultIsModuleExports =
      typeof defaultIsModuleExportsOption === 'function'
        ? defaultIsModuleExportsOption
        : () =>
            typeof defaultIsModuleExportsOption === 'boolean' ? defaultIsModuleExportsOption : 'auto';

    const dynamicRequireRoot =
      typeof options.dynamicRequireRoot === 'string'
        ? require$$0.resolve(options.dynamicRequireRoot)
        : process.cwd();
    const { commonDir, dynamicRequireModules } = getDynamicRequireModules(
      options.dynamicRequireTargets,
      dynamicRequireRoot
    );
    const isDynamicRequireModulesEnabled = dynamicRequireModules.size > 0;

    const ignoreRequire =
      typeof options.ignore === 'function'
        ? options.ignore
        : Array.isArray(options.ignore)
        ? (id) => options.ignore.includes(id)
        : () => false;

    const getIgnoreTryCatchRequireStatementMode = (id) => {
      const mode =
        typeof options.ignoreTryCatch === 'function'
          ? options.ignoreTryCatch(id)
          : Array.isArray(options.ignoreTryCatch)
          ? options.ignoreTryCatch.includes(id)
          : typeof options.ignoreTryCatch !== 'undefined'
          ? options.ignoreTryCatch
          : true;

      return {
        canConvertRequire: mode !== 'remove' && mode !== true,
        shouldRemoveRequire: mode === 'remove'
      };
    };

    const { currentlyResolving, resolveId } = getResolveId(extensions, isPossibleCjsId);

    const sourceMap = options.sourceMap !== false;

    // Initialized in buildStart
    let requireResolver;

    function transformAndCheckExports(code, id) {
      const normalizedId = normalizePathSlashes(id);
      const { isEsModule, hasDefaultExport, hasNamedExports, ast } = analyzeTopLevelStatements(
        this.parse,
        code,
        id
      );

      const commonjsMeta = this.getModuleInfo(id).meta.commonjs || {};
      if (hasDefaultExport) {
        commonjsMeta.hasDefaultExport = true;
      }
      if (hasNamedExports) {
        commonjsMeta.hasNamedExports = true;
      }

      if (
        !dynamicRequireModules.has(normalizedId) &&
        (!(hasCjsKeywords(code, ignoreGlobal) || requireResolver.isRequiredId(id)) ||
          (isEsModule && !options.transformMixedEsModules))
      ) {
        commonjsMeta.isCommonJS = false;
        return { meta: { commonjs: commonjsMeta } };
      }

      const needsRequireWrapper =
        !isEsModule && (dynamicRequireModules.has(normalizedId) || strictRequiresFilter(id));

      const checkDynamicRequire = (position) => {
        const normalizedDynamicRequireRoot = normalizePathSlashes(dynamicRequireRoot);

        if (normalizedId.indexOf(normalizedDynamicRequireRoot) !== 0) {
          this.error(
            {
              code: 'DYNAMIC_REQUIRE_OUTSIDE_ROOT',
              normalizedId,
              normalizedDynamicRequireRoot,
              message: `"${normalizedId}" contains dynamic require statements but it is not within the current dynamicRequireRoot "${normalizedDynamicRequireRoot}". You should set dynamicRequireRoot to "${require$$0.dirname(
              normalizedId
            )}" or one of its parent directories.`
            },
            position
          );
        }
      };

      return transformCommonjs(
        this.parse,
        code,
        id,
        isEsModule,
        ignoreGlobal || isEsModule,
        ignoreRequire,
        ignoreDynamicRequires && !isDynamicRequireModulesEnabled,
        getIgnoreTryCatchRequireStatementMode,
        sourceMap,
        isDynamicRequireModulesEnabled,
        dynamicRequireModules,
        commonDir,
        ast,
        getDefaultIsModuleExports(id),
        needsRequireWrapper,
        requireResolver.resolveRequireSourcesAndUpdateMeta(this),
        requireResolver.isRequiredId(id),
        checkDynamicRequire,
        commonjsMeta
      );
    }

    return {
      name: PLUGIN_NAME,

      version,

      options(rawOptions) {
        // We inject the resolver in the beginning so that "catch-all-resolver" like node-resolver
        // do not prevent our plugin from resolving entry points ot proxies.
        const plugins = Array.isArray(rawOptions.plugins)
          ? [...rawOptions.plugins]
          : rawOptions.plugins
          ? [rawOptions.plugins]
          : [];
        plugins.unshift({
          name: 'commonjs--resolver',
          resolveId
        });
        return { ...rawOptions, plugins };
      },

      buildStart({ plugins }) {
        validateVersion(this.meta.rollupVersion, peerDependencies.rollup, 'rollup');
        const nodeResolve = plugins.find(({ name }) => name === 'node-resolve');
        if (nodeResolve) {
          validateVersion(nodeResolve.version, '^13.0.6', '@rollup/plugin-node-resolve');
        }
        if (options.namedExports != null) {
          this.warn(
            'The namedExports option from "@rollup/plugin-commonjs" is deprecated. Named exports are now handled automatically.'
          );
        }
        requireResolver = getRequireResolver(
          extensions,
          detectCyclesAndConditional,
          currentlyResolving
        );
      },

      buildEnd() {
        if (options.strictRequires === 'debug') {
          const wrappedIds = requireResolver.getWrappedIds();
          if (wrappedIds.length) {
            this.warn({
              code: 'WRAPPED_IDS',
              ids: wrappedIds,
              message: `The commonjs plugin automatically wrapped the following files:\n[\n${wrappedIds
              .map((id) => `\t${JSON.stringify(require$$0.relative(process.cwd(), id))}`)
              .join(',\n')}\n]`
            });
          } else {
            this.warn({
              code: 'WRAPPED_IDS',
              ids: wrappedIds,
              message: 'The commonjs plugin did not wrap any files.'
            });
          }
        }
      },

      async load(id) {
        if (id === HELPERS_ID) {
          return getHelpersModule();
        }

        if (isWrappedId(id, MODULE_SUFFIX)) {
          const name = getName(unwrapId(id, MODULE_SUFFIX));
          return {
            code: `var ${name} = {exports: {}}; export {${name} as __module}`,
            meta: { commonjs: { isCommonJS: false } }
          };
        }

        if (isWrappedId(id, EXPORTS_SUFFIX)) {
          const name = getName(unwrapId(id, EXPORTS_SUFFIX));
          return {
            code: `var ${name} = {}; export {${name} as __exports}`,
            meta: { commonjs: { isCommonJS: false } }
          };
        }

        if (isWrappedId(id, EXTERNAL_SUFFIX)) {
          const actualId = unwrapId(id, EXTERNAL_SUFFIX);
          return getUnknownRequireProxy(
            actualId,
            isEsmExternal(actualId) ? getRequireReturnsDefault(actualId) : true
          );
        }

        // entry suffix is just appended to not mess up relative external resolution
        if (id.endsWith(ENTRY_SUFFIX)) {
          const acutalId = id.slice(0, -ENTRY_SUFFIX.length);
          const {
            meta: { commonjs: commonjsMeta }
          } = this.getModuleInfo(acutalId);
          const shebang = commonjsMeta?.shebang ?? '';
          return getEntryProxy(
            acutalId,
            getDefaultIsModuleExports(acutalId),
            this.getModuleInfo,
            shebang
          );
        }

        if (isWrappedId(id, ES_IMPORT_SUFFIX)) {
          const actualId = unwrapId(id, ES_IMPORT_SUFFIX);
          return getEsImportProxy(
            actualId,
            getDefaultIsModuleExports(actualId),
            (await this.load({ id: actualId })).moduleSideEffects
          );
        }

        if (id === DYNAMIC_MODULES_ID) {
          return getDynamicModuleRegistry(
            isDynamicRequireModulesEnabled,
            dynamicRequireModules,
            commonDir,
            ignoreDynamicRequires
          );
        }

        if (isWrappedId(id, PROXY_SUFFIX)) {
          const actualId = unwrapId(id, PROXY_SUFFIX);
          return getStaticRequireProxy(actualId, getRequireReturnsDefault(actualId), this.load);
        }

        return null;
      },

      shouldTransformCachedModule(...args) {
        return requireResolver.shouldTransformCachedModule.call(this, ...args);
      },

      transform(code, id) {
        if (!isPossibleCjsId(id)) return null;

        try {
          return transformAndCheckExports.call(this, code, id);
        } catch (err) {
          return this.error(err, err.pos);
        }
      }
    };
  }

  const imgElement = document.createElement('img');
  imgElement.src = img; // Используем импортированное изображение
  imgElement.alt = 'Modern Image'; // Добавьте атрибут alt для лучшей доступности
  document.body.appendChild(imgElement);

  console.log(img);
  console.log('Hello World!, Hello JavaScript!');

  var index = {
      plugins: [commonjs()]
  };

  return index;

})(require$$0, require$$0$1);
